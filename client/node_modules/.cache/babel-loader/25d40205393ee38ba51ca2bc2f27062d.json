{"ast":null,"code":"/**\n * A simple function that does some prototype magic extend this in your classes\n * to make your class instance callable and pointing to a method in it\n * the library uses this to make the instance callable defaulting to a method\n * choosen in options so you don't need to specify the method name\n * but you may use it in your apps too if you wish.\n * @param {String} prop - The property name for the function\n * @example\n * class MyClass exrends Callable {\n *   constructor() {\n *     super(\"method\");\n *   }\n *\n *   method() {\n *     return \"method!\";\n *   }\n *\n *   another() {\n *     return \"another!\";\n *   }\n * }\n *\n * const inst = new MyClass();\n * // Calls inst.method()\n * console.log(inst()); // => method!\n * console.log(inst.another()); // => another!\n * console.log(inst.method()); // => method!\n */\nfunction Callable(prop) {\n  const fn = this.constructor.prototype[prop];\n\n  const apply = function () {\n    return fn.apply(apply, arguments);\n  };\n\n  Object.setPrototypeOf(apply, this.constructor.prototype);\n  Object.getOwnPropertyNames(fn).forEach(prop => {\n    Object.defineProperty(apply, prop, Object.getOwnPropertyDescriptors(fn, prop));\n  });\n  return apply;\n}\n\nCallable.prototype = Object.create(Function.prototype);\nmodule.exports = Callable;","map":{"version":3,"sources":["/home/conrad/Documents/tarot/tarot-cards/node_modules/ladybug-fetch/src/utils/callable.js"],"names":["Callable","prop","fn","constructor","prototype","apply","arguments","Object","setPrototypeOf","getOwnPropertyNames","forEach","defineProperty","getOwnPropertyDescriptors","create","Function","module","exports"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAT,CAAkBC,IAAlB,EAAwB;AACtB,QAAMC,EAAE,GAAG,KAAKC,WAAL,CAAiBC,SAAjB,CAA2BH,IAA3B,CAAX;;AACA,QAAMI,KAAK,GAAG,YAAW;AACvB,WAAOH,EAAE,CAACG,KAAH,CAASA,KAAT,EAAgBC,SAAhB,CAAP;AACD,GAFD;;AAGAC,EAAAA,MAAM,CAACC,cAAP,CAAsBH,KAAtB,EAA6B,KAAKF,WAAL,CAAiBC,SAA9C;AACAG,EAAAA,MAAM,CAACE,mBAAP,CAA2BP,EAA3B,EAA+BQ,OAA/B,CAAwCT,IAAD,IAAU;AAC/CM,IAAAA,MAAM,CAACI,cAAP,CAAsBN,KAAtB,EAA6BJ,IAA7B,EAAmCM,MAAM,CAACK,yBAAP,CAAiCV,EAAjC,EAAqCD,IAArC,CAAnC;AACD,GAFD;AAGA,SAAOI,KAAP;AACD;;AAEDL,QAAQ,CAACI,SAAT,GAAqBG,MAAM,CAACM,MAAP,CAAcC,QAAQ,CAACV,SAAvB,CAArB;AAEAW,MAAM,CAACC,OAAP,GAAiBhB,QAAjB","sourcesContent":["\n/**\n * A simple function that does some prototype magic extend this in your classes\n * to make your class instance callable and pointing to a method in it\n * the library uses this to make the instance callable defaulting to a method\n * choosen in options so you don't need to specify the method name\n * but you may use it in your apps too if you wish.\n * @param {String} prop - The property name for the function\n * @example\n * class MyClass exrends Callable {\n *   constructor() {\n *     super(\"method\");\n *   }\n *\n *   method() {\n *     return \"method!\";\n *   }\n *\n *   another() {\n *     return \"another!\";\n *   }\n * }\n *\n * const inst = new MyClass();\n * // Calls inst.method()\n * console.log(inst()); // => method!\n * console.log(inst.another()); // => another!\n * console.log(inst.method()); // => method!\n */\nfunction Callable(prop) {\n  const fn = this.constructor.prototype[prop];\n  const apply = function() {\n    return fn.apply(apply, arguments);\n  };\n  Object.setPrototypeOf(apply, this.constructor.prototype);\n  Object.getOwnPropertyNames(fn).forEach((prop) => {\n    Object.defineProperty(apply, prop, Object.getOwnPropertyDescriptors(fn, prop));\n  });\n  return apply;\n}\n\nCallable.prototype = Object.create(Function.prototype);\n\nmodule.exports = Callable;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"const finalizeOptions = require(\"./options.js\");\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nconst zlib = require(\"zlib\");\n\nconst Response = require(\"./LadybugResponse.js\");\n\nfunction shouldUnzip(res) {\n  // No Content, no unzip\n  if (res.statusCode === 204) return false;\n  if (res.headers[\"content-length\"] === \"0\") return false;\n  return /(gzip|deflate|compress)/ig.test(res.headers[\"content-encoding\"]);\n}\n\nconst isStream = s => typeof s === \"object\" && typeof s.pipe === \"function\";\n\nmodule.exports = request => {\n  request.plugins.map(plugin => plugin(request));\n  return new request.promiseLibrary((resolve, reject) => {\n    const options = finalizeOptions(request);\n    const lib = {\n      \"https:\": https,\n      \"http:\": http\n    }[options.protocol];\n    if (!lib) return reject(`Invalid or Unsupported Protocol '${options.protocol}'`);\n    const req = lib.request(options);\n    req.on(\"response\", res => {\n      const buffer = [];\n      let stream = res;\n      if (shouldUnzip(res)) stream = stream.pipe(zlib.createUnzip());\n      stream.on(\"data\", chunk => buffer.push(chunk)).on(\"error\", err => reject(err)).on(\"end\", () => {\n        const body = Buffer.concat(buffer);\n        const response = new Response(res, body);\n        const status = request.validateStatus(res.statusCode);\n        if (status) return resolve(response);\n        const err = new Error(`${res.statusCode} ${http.STATUS_CODES[res.statusCode]}`);\n        err.response = response;\n        err.status = res.statusCode;\n        return reject(err);\n      });\n    });\n    req.once(\"error\", err => reject(err));\n    req.once(\"abort\", () => reject(new Error(\"Request Aborted\")));\n\n    if (request.data) {\n      if (isStream(request.data)) request.data.pipe(req);else if (Array.isArray(request.data)) {\n        for (const chunk of request.data) req.write(chunk);\n\n        req.end();\n      } else req.end(request.data);\n    } else if (request.form) {\n      req.end(request.form.build());\n    } else req.end();\n  });\n};","map":{"version":3,"sources":["/home/conrad/Documents/tarot/tarot-cards/node_modules/ladybug-fetch/src/request.js"],"names":["finalizeOptions","require","http","https","zlib","Response","shouldUnzip","res","statusCode","headers","test","isStream","s","pipe","module","exports","request","plugins","map","plugin","promiseLibrary","resolve","reject","options","lib","protocol","req","on","buffer","stream","createUnzip","chunk","push","err","body","Buffer","concat","response","status","validateStatus","Error","STATUS_CODES","once","data","Array","isArray","write","end","form","build"],"mappings":"AAAA,MAAMA,eAAe,GAAGC,OAAO,CAAC,cAAD,CAA/B;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,sBAAD,CAAxB;;AAEA,SAASK,WAAT,CAAqBC,GAArB,EAA0B;AACxB;AACA,MAAGA,GAAG,CAACC,UAAJ,KAAmB,GAAtB,EAA2B,OAAO,KAAP;AAC3B,MAAGD,GAAG,CAACE,OAAJ,CAAY,gBAAZ,MAAkC,GAArC,EAA0C,OAAO,KAAP;AAC1C,SAAO,4BAA4BC,IAA5B,CAAiCH,GAAG,CAACE,OAAJ,CAAY,kBAAZ,CAAjC,CAAP;AACD;;AAED,MAAME,QAAQ,GAAGC,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAb,IAAyB,OAAOA,CAAC,CAACC,IAAT,KAAkB,UAAjE;;AAEAC,MAAM,CAACC,OAAP,GAAkBC,OAAD,IAAa;AAC5BA,EAAAA,OAAO,CAACC,OAAR,CAAgBC,GAAhB,CAAqBC,MAAD,IAAYA,MAAM,CAACH,OAAD,CAAtC;AACA,SAAO,IAAIA,OAAO,CAACI,cAAZ,CAA2B,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrD,UAAMC,OAAO,GAAGvB,eAAe,CAACgB,OAAD,CAA/B;AACA,UAAMQ,GAAG,GAAG;AAAE,gBAAUrB,KAAZ;AAAmB,eAASD;AAA5B,MAAmCqB,OAAO,CAACE,QAA3C,CAAZ;AACA,QAAG,CAACD,GAAJ,EAAS,OAAOF,MAAM,CAAE,oCAAmCC,OAAO,CAACE,QAAS,GAAtD,CAAb;AACT,UAAMC,GAAG,GAAGF,GAAG,CAACR,OAAJ,CAAYO,OAAZ,CAAZ;AAEAG,IAAAA,GAAG,CAACC,EAAJ,CAAO,UAAP,EAAoBpB,GAAD,IAAS;AAC1B,YAAMqB,MAAM,GAAG,EAAf;AACA,UAAIC,MAAM,GAAGtB,GAAb;AACA,UAAGD,WAAW,CAACC,GAAD,CAAd,EAAqBsB,MAAM,GAAGA,MAAM,CAAChB,IAAP,CAAYT,IAAI,CAAC0B,WAAL,EAAZ,CAAT;AAErBD,MAAAA,MAAM,CACHF,EADH,CACM,MADN,EACeI,KAAD,IAAWH,MAAM,CAACI,IAAP,CAAYD,KAAZ,CADzB,EAEGJ,EAFH,CAEM,OAFN,EAEgBM,GAAD,IAASX,MAAM,CAACW,GAAD,CAF9B,EAGGN,EAHH,CAGM,KAHN,EAGa,MAAM;AACf,cAAMO,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAcR,MAAd,CAAb;AACA,cAAMS,QAAQ,GAAG,IAAIhC,QAAJ,CAAaE,GAAb,EAAkB2B,IAAlB,CAAjB;AACA,cAAMI,MAAM,GAAGtB,OAAO,CAACuB,cAAR,CAAuBhC,GAAG,CAACC,UAA3B,CAAf;AACA,YAAG8B,MAAH,EAAW,OAAOjB,OAAO,CAACgB,QAAD,CAAd;AACX,cAAMJ,GAAG,GAAG,IAAIO,KAAJ,CAAW,GAAEjC,GAAG,CAACC,UAAW,IAAGN,IAAI,CAACuC,YAAL,CAAkBlC,GAAG,CAACC,UAAtB,CAAkC,EAAjE,CAAZ;AACAyB,QAAAA,GAAG,CAACI,QAAJ,GAAeA,QAAf;AACAJ,QAAAA,GAAG,CAACK,MAAJ,GAAa/B,GAAG,CAACC,UAAjB;AACA,eAAOc,MAAM,CAACW,GAAD,CAAb;AACD,OAZH;AAaD,KAlBD;AAoBAP,IAAAA,GAAG,CAACgB,IAAJ,CAAS,OAAT,EAAmBT,GAAD,IAASX,MAAM,CAACW,GAAD,CAAjC;AACAP,IAAAA,GAAG,CAACgB,IAAJ,CAAS,OAAT,EAAkB,MAAMpB,MAAM,CAAC,IAAIkB,KAAJ,CAAU,iBAAV,CAAD,CAA9B;;AAEA,QAAGxB,OAAO,CAAC2B,IAAX,EAAiB;AACf,UAAGhC,QAAQ,CAACK,OAAO,CAAC2B,IAAT,CAAX,EAA2B3B,OAAO,CAAC2B,IAAR,CAAa9B,IAAb,CAAkBa,GAAlB,EAA3B,KACK,IAAGkB,KAAK,CAACC,OAAN,CAAc7B,OAAO,CAAC2B,IAAtB,CAAH,EAAgC;AACnC,aAAI,MAAMZ,KAAV,IAAmBf,OAAO,CAAC2B,IAA3B,EAAiCjB,GAAG,CAACoB,KAAJ,CAAUf,KAAV;;AACjCL,QAAAA,GAAG,CAACqB,GAAJ;AACD,OAHI,MAIArB,GAAG,CAACqB,GAAJ,CAAQ/B,OAAO,CAAC2B,IAAhB;AACN,KAPD,MAOO,IAAG3B,OAAO,CAACgC,IAAX,EAAiB;AACtBtB,MAAAA,GAAG,CAACqB,GAAJ,CAAQ/B,OAAO,CAACgC,IAAR,CAAaC,KAAb,EAAR;AACD,KAFM,MAEAvB,GAAG,CAACqB,GAAJ;AACR,GAvCM,CAAP;AAwCD,CA1CD","sourcesContent":["const finalizeOptions = require(\"./options.js\");\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst zlib = require(\"zlib\");\nconst Response = require(\"./LadybugResponse.js\");\n\nfunction shouldUnzip(res) {\n  // No Content, no unzip\n  if(res.statusCode === 204) return false;\n  if(res.headers[\"content-length\"] === \"0\") return false;\n  return /(gzip|deflate|compress)/ig.test(res.headers[\"content-encoding\"]);\n}\n\nconst isStream = s => typeof s === \"object\" && typeof s.pipe === \"function\";\n\nmodule.exports = (request) => {\n  request.plugins.map((plugin) => plugin(request));\n  return new request.promiseLibrary((resolve, reject) => {\n    const options = finalizeOptions(request);\n    const lib = { \"https:\": https, \"http:\": http }[options.protocol];\n    if(!lib) return reject(`Invalid or Unsupported Protocol '${options.protocol}'`);\n    const req = lib.request(options);\n\n    req.on(\"response\", (res) => {\n      const buffer = [];\n      let stream = res;\n      if(shouldUnzip(res)) stream = stream.pipe(zlib.createUnzip());\n\n      stream\n        .on(\"data\", (chunk) => buffer.push(chunk))\n        .on(\"error\", (err) => reject(err))\n        .on(\"end\", () => {\n          const body = Buffer.concat(buffer);\n          const response = new Response(res, body);\n          const status = request.validateStatus(res.statusCode);\n          if(status) return resolve(response);\n          const err = new Error(`${res.statusCode} ${http.STATUS_CODES[res.statusCode]}`);\n          err.response = response;\n          err.status = res.statusCode;\n          return reject(err);\n        });\n    });\n\n    req.once(\"error\", (err) => reject(err));\n    req.once(\"abort\", () => reject(new Error(\"Request Aborted\")));\n\n    if(request.data) {\n      if(isStream(request.data)) request.data.pipe(req);\n      else if(Array.isArray(request.data)) {\n        for(const chunk of request.data) req.write(chunk);\n        req.end();\n      }\n      else req.end(request.data);\n    } else if(request.form) {\n      req.end(request.form.build());\n    } else req.end();\n  });\n};\n"]},"metadata":{},"sourceType":"script"}
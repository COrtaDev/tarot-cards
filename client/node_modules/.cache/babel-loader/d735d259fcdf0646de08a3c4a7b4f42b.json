{"ast":null,"code":"'use strict';\n\nvar toString = Object.prototype.toString;\n/**\n * Extract names from functions.\n *\n * @param {Function} fn The function who's name we need to extract.\n * @returns {String} The name of the function.\n * @public\n */\n\nmodule.exports = function name(fn) {\n  if ('string' === typeof fn.displayName && fn.constructor.name) {\n    return fn.displayName;\n  } else if ('string' === typeof fn.name && fn.name) {\n    return fn.name;\n  } //\n  // Check to see if the constructor has a name.\n  //\n\n\n  if ('object' === typeof fn && fn.constructor && 'string' === typeof fn.constructor.name) return fn.constructor.name; //\n  // toString the given function and attempt to parse it out of it, or determine\n  // the class.\n  //\n\n  var named = fn.toString(),\n      type = toString.call(fn).slice(8, -1);\n\n  if ('Function' === type) {\n    named = named.substring(named.indexOf('(') + 1, named.indexOf(')'));\n  } else {\n    named = type;\n  }\n\n  return named || 'anonymous';\n};","map":{"version":3,"sources":["/home/conrad/Documents/tarot/tarot-cards/node_modules/fn.name/index.js"],"names":["toString","Object","prototype","module","exports","name","fn","displayName","constructor","named","type","call","slice","substring","indexOf"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,SAAP,CAAiBF,QAAhC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAG,MAAM,CAACC,OAAP,GAAiB,SAASC,IAAT,CAAcC,EAAd,EAAkB;AACjC,MAAI,aAAa,OAAOA,EAAE,CAACC,WAAvB,IAAsCD,EAAE,CAACE,WAAH,CAAeH,IAAzD,EAA+D;AAC7D,WAAOC,EAAE,CAACC,WAAV;AACD,GAFD,MAEO,IAAI,aAAa,OAAOD,EAAE,CAACD,IAAvB,IAA+BC,EAAE,CAACD,IAAtC,EAA4C;AACjD,WAAOC,EAAE,CAACD,IAAV;AACD,GALgC,CAOjC;AACA;AACA;;;AACA,MACK,aAAa,OAAOC,EAApB,IACAA,EAAE,CAACE,WADH,IAEA,aAAa,OAAOF,EAAE,CAACE,WAAH,CAAeH,IAHxC,EAIE,OAAOC,EAAE,CAACE,WAAH,CAAeH,IAAtB,CAd+B,CAgBjC;AACA;AACA;AACA;;AACA,MAAII,KAAK,GAAGH,EAAE,CAACN,QAAH,EAAZ;AAAA,MACIU,IAAI,GAAGV,QAAQ,CAACW,IAAT,CAAcL,EAAd,EAAkBM,KAAlB,CAAwB,CAAxB,EAA2B,CAAC,CAA5B,CADX;;AAGA,MAAI,eAAeF,IAAnB,EAAyB;AACvBD,IAAAA,KAAK,GAAGA,KAAK,CAACI,SAAN,CAAgBJ,KAAK,CAACK,OAAN,CAAc,GAAd,IAAqB,CAArC,EAAwCL,KAAK,CAACK,OAAN,CAAc,GAAd,CAAxC,CAAR;AACD,GAFD,MAEO;AACLL,IAAAA,KAAK,GAAGC,IAAR;AACD;;AAED,SAAOD,KAAK,IAAI,WAAhB;AACD,CA9BD","sourcesContent":["'use strict';\n\nvar toString = Object.prototype.toString;\n\n/**\n * Extract names from functions.\n *\n * @param {Function} fn The function who's name we need to extract.\n * @returns {String} The name of the function.\n * @public\n */\nmodule.exports = function name(fn) {\n  if ('string' === typeof fn.displayName && fn.constructor.name) {\n    return fn.displayName;\n  } else if ('string' === typeof fn.name && fn.name) {\n    return fn.name;\n  }\n\n  //\n  // Check to see if the constructor has a name.\n  //\n  if (\n       'object' === typeof fn\n    && fn.constructor\n    && 'string' === typeof fn.constructor.name\n  ) return fn.constructor.name;\n\n  //\n  // toString the given function and attempt to parse it out of it, or determine\n  // the class.\n  //\n  var named = fn.toString()\n    , type = toString.call(fn).slice(8, -1);\n\n  if ('Function' === type) {\n    named = named.substring(named.indexOf('(') + 1, named.indexOf(')'));\n  } else {\n    named = type;\n  }\n\n  return named || 'anonymous';\n};\n"]},"metadata":{},"sourceType":"script"}
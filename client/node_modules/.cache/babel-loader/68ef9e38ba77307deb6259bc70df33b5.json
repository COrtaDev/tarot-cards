{"ast":null,"code":"const querystring = require(\"querystring\");\n\nconst mime = require(\"./mime.js\");\n\nconst FormData = require(\"./FormData.js\");\n/**\n * The base request class implementing the chainable methods.\n * i.e `.set()` `.query()`\n * this is subclassed by {@link Ladybug} and {@link LadybugRequest}\n * to reduce duplicate code for defining this functions.\n * @private\n */\n\n\nclass RequestBase {\n  constructor(options = {}) {\n    this.baseURL = options.baseURL;\n    this.headers = options.headers || {};\n    this._query = options.query || {};\n    this.data = options.data || null;\n    this.promiseLibrary = options.promise || Promise;\n    this.plugins = options.plugins || [];\n    this.form = null;\n\n    this.validateStatus = options.status || function (s) {\n      return s >= 200 && s < 400;\n    };\n  }\n  /**\n   * Attachs a multipart/form-data field\n   * NOTE: do not set Content-Type header when using this, the library will set\n   * the appropriate header with boundary.\n   * @param {String} name - Field name\n   * @param {Buffer|Object|String} value - Field data\n   * @param {String} [filename] - filename if attaching a file, the extension will also be used to find the mime type.\n   * @returns {this}\n   */\n\n\n  attach(name, value, filename) {\n    if (this.data) throw new TypeError(\"Cannot mix form data with .send()\");\n    if (!this.form) this.form = new FormData();\n    this.form.append(name, value, filename);\n    return this;\n  }\n  /**\n   * Sets a header value\n   * @param {String|Object} key - Header object or a string for key\n   * @param {String} value - Header value optional if key is a query or object\n   * @returns {this}\n   * @example\n   * req.set({ Authorization: \"FooBar\", Foo: \"Bar\" }); // Object\n   * req.set(\"Authorization\", \"FooBar\"); // Key, Value\n   * req.set(\"Authorization=FooBar&Foo=Bar\"); // Querystring\n   */\n\n\n  set(key, value) {\n    if (typeof key === \"object\") {\n      // .set({ Authorization: \"foobar\" });\n      Object.assign(this.headers, key);\n      return this;\n    }\n\n    if (typeof key === \"string\" && typeof value === \"string\") {\n      // .set(\"foo\", \"bar\")\n      this.headers[key] = value;\n      return this;\n    }\n\n    if (typeof key === \"string\") {\n      // .set(\"Authorization=foo&another=bar\");\n      Object.assign(this.headers, querystring.parse(key));\n      return this;\n    }\n\n    throw new Error(\"Arguments did not match any of overloads (str, str), (str), (object)\");\n  }\n\n  query(key, value) {\n    if (typeof key === \"object\") {\n      Object.assign(this._query, key);\n      return this;\n    }\n\n    if (typeof key === \"string\" && typeof value === \"string\") {\n      this._query[key] = value;\n      return this;\n    }\n\n    if (typeof key === \"string\") {\n      Object.assign(this._query, querystring.parse(key));\n      return this;\n    }\n\n    throw new Error(\"Arguments did not match any of overloads (str, str), (str), (object)\");\n  }\n  /**\n   * Send some data to the server\n   * @param {Object|String|Buffer|Stream} data - The data to send\n   * @returns {this}\n   */\n\n\n  send(data) {\n    if (this.form) throw new TypeError(\"Cannot mix data with .attach()\");\n\n    if (this.headers[\"Content-Type\"] && this.headers[\"Content-Type\"].includes(\"application/x-www-form-urlencoded\")) {\n      this.data = querystring.stringify(data);\n    } else if (typeof data === \"object\") {\n      this.data = JSON.stringify(data);\n      this.set(\"Content-Type\", \"application/json\");\n    } else this.data = data;\n\n    return this;\n  }\n  /**\n   * Changes the current promise library being used, note the promise library\n   * must have a similar interface to the native one\n   * The default library is the global `Promise` so incase you are overriding the\n   * global promise this is unnecessary\n   * @param {any} lib - The promise library\n   * @returns {this}\n   * @example\n   * req.promise(require(\"bluebird\"));\n   */\n\n\n  promise(lib) {\n    this.promiseLibrary = lib;\n    return this;\n  }\n  /**\n   * Adds a plugin\n   * @param {Function} plugin - The plugin function\n   * @returns {this}\n   */\n\n\n  use(plugin) {\n    if (typeof plugin !== \"function\") throw new Error(\"Plugin must be a function\");\n    this.plugins.add(plugin);\n    return this;\n  }\n\n  json() {\n    return this.set(\"Content-Type\", \"application/json\");\n  }\n\n  status(callback) {\n    if (typeof callback !== \"function\") throw new Error(\"Callback must be a function\");\n    this.validateStatus = callback;\n    return this;\n  }\n\n  accept(ext) {\n    return this.set(\"Accept\", mime.lookup(ext));\n  } // For Ladybug class since it extends another class while i also need this methods\n  // so we will add it through prototypes\n\n\n  static applyTo(cls, ignore = []) {\n    for (const prop of [\"set\", \"query\", \"promise\", \"use\", \"status\", \"send\", \"json\", \"accept\", \"attach\"]) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(cls.prototype, prop, Object.getOwnPropertyDescriptor(RequestBase.prototype, prop));\n    }\n  }\n\n}\n\nmodule.exports = RequestBase;","map":{"version":3,"sources":["/home/conrad/Documents/tarot/tarot-cards/node_modules/ladybug-fetch/src/RequestBase.js"],"names":["querystring","require","mime","FormData","RequestBase","constructor","options","baseURL","headers","_query","query","data","promiseLibrary","promise","Promise","plugins","form","validateStatus","status","s","attach","name","value","filename","TypeError","append","set","key","Object","assign","parse","Error","send","includes","stringify","JSON","lib","use","plugin","add","json","callback","accept","ext","lookup","applyTo","cls","ignore","prop","defineProperty","prototype","getOwnPropertyDescriptor","module","exports"],"mappings":"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","sourcesContent":["const querystring = require(\"querystring\");\nconst mime = require(\"./mime.js\");\nconst FormData = require(\"./FormData.js\");\n\n/**\n * The base request class implementing the chainable methods.\n * i.e `.set()` `.query()`\n * this is subclassed by {@link Ladybug} and {@link LadybugRequest}\n * to reduce duplicate code for defining this functions.\n * @private\n */\nclass RequestBase {\n  constructor(options = {}) {\n    this.baseURL = options.baseURL;\n    this.headers = options.headers || {};\n    this._query = options.query || {};\n    this.data = options.data || null;\n    this.promiseLibrary = options.promise || Promise;\n    this.plugins = options.plugins || [];\n    this.form = null;\n    this.validateStatus = options.status || function(s) { return s >= 200 && s < 400; };\n  }\n\n  /**\n   * Attachs a multipart/form-data field\n   * NOTE: do not set Content-Type header when using this, the library will set\n   * the appropriate header with boundary.\n   * @param {String} name - Field name\n   * @param {Buffer|Object|String} value - Field data\n   * @param {String} [filename] - filename if attaching a file, the extension will also be used to find the mime type.\n   * @returns {this}\n   */\n  attach(name, value, filename) {\n    if(this.data) throw new TypeError(\"Cannot mix form data with .send()\");\n    if(!this.form) this.form = new FormData();\n    this.form.append(name, value, filename);\n    return this;\n  }\n\n  /**\n   * Sets a header value\n   * @param {String|Object} key - Header object or a string for key\n   * @param {String} value - Header value optional if key is a query or object\n   * @returns {this}\n   * @example\n   * req.set({ Authorization: \"FooBar\", Foo: \"Bar\" }); // Object\n   * req.set(\"Authorization\", \"FooBar\"); // Key, Value\n   * req.set(\"Authorization=FooBar&Foo=Bar\"); // Querystring\n   */\n  set(key, value) {\n    if(typeof key === \"object\") { // .set({ Authorization: \"foobar\" });\n      Object.assign(this.headers, key);\n      return this;\n    }\n    if(typeof key === \"string\" && typeof value === \"string\") { // .set(\"foo\", \"bar\")\n      this.headers[key] = value;\n      return this;\n    }\n    if(typeof key === \"string\") { // .set(\"Authorization=foo&another=bar\");\n      Object.assign(this.headers, querystring.parse(key));\n      return this;\n    }\n    throw new Error(\"Arguments did not match any of overloads (str, str), (str), (object)\");\n  }\n\n  query(key, value) {\n    if(typeof key === \"object\") {\n      Object.assign(this._query, key);\n      return this;\n    }\n    if(typeof key === \"string\" && typeof value === \"string\") {\n      this._query[key] = value;\n      return this;\n    }\n    if(typeof key === \"string\") {\n      Object.assign(this._query, querystring.parse(key));\n      return this;\n    }\n    throw new Error(\"Arguments did not match any of overloads (str, str), (str), (object)\");\n  }\n\n  /**\n   * Send some data to the server\n   * @param {Object|String|Buffer|Stream} data - The data to send\n   * @returns {this}\n   */\n  send(data) {\n    if(this.form) throw new TypeError(\"Cannot mix data with .attach()\");\n    if(this.headers[\"Content-Type\"] && this.headers[\"Content-Type\"].includes(\"application/x-www-form-urlencoded\")) {\n      this.data = querystring.stringify(data);\n    } else if(typeof data === \"object\") {\n      this.data = JSON.stringify(data);\n      this.set(\"Content-Type\", \"application/json\");\n    } else this.data = data;\n    return this;\n  }\n\n  /**\n   * Changes the current promise library being used, note the promise library\n   * must have a similar interface to the native one\n   * The default library is the global `Promise` so incase you are overriding the\n   * global promise this is unnecessary\n   * @param {any} lib - The promise library\n   * @returns {this}\n   * @example\n   * req.promise(require(\"bluebird\"));\n   */\n  promise(lib) {\n    this.promiseLibrary = lib;\n    return this;\n  }\n\n  /**\n   * Adds a plugin\n   * @param {Function} plugin - The plugin function\n   * @returns {this}\n   */\n  use(plugin) {\n    if(typeof plugin !== \"function\") throw new Error(\"Plugin must be a function\");\n    this.plugins.add(plugin);\n    return this;\n  }\n\n  json() {\n    return this.set(\"Content-Type\", \"application/json\");\n  }\n\n  status(callback) {\n    if(typeof callback !== \"function\") throw new Error(\"Callback must be a function\");\n    this.validateStatus = callback;\n    return this;\n  }\n\n  accept(ext) {\n    return this.set(\"Accept\", mime.lookup(ext));\n  }\n\n  // For Ladybug class since it extends another class while i also need this methods\n  // so we will add it through prototypes\n  static applyTo(cls, ignore = []) {\n    for(const prop of [\"set\", \"query\", \"promise\", \"use\", \"status\", \"send\", \"json\", \"accept\", \"attach\"]) {\n      if(ignore.includes(prop)) continue;\n      Object.defineProperty(cls.prototype, prop, Object.getOwnPropertyDescriptor(RequestBase.prototype, prop));\n    }\n  }\n}\n\nmodule.exports = RequestBase;\n"]},"metadata":{},"sourceType":"script"}
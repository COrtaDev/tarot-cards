{"ast":null,"code":"\"use strict\";\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;\n\nvar boolbase_1 = require(\"boolbase\");\n\nvar procedure_1 = require(\"../procedure\");\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\n\n\nexports.PLACEHOLDER_ELEMENT = {};\n\nfunction containsTraversal(t) {\n  return t.some(procedure_1.isTraversal);\n}\n\nfunction ensureIsTag(next, adapter) {\n  if (next === boolbase_1.falseFunc) return next;\n  return function (elem) {\n    return adapter.isTag(elem) && next(elem);\n  };\n}\n\nexports.ensureIsTag = ensureIsTag;\n\nfunction getNextSiblings(elem, adapter) {\n  var siblings = adapter.getSiblings(elem);\n  if (siblings.length <= 1) return [];\n  var elemIndex = siblings.indexOf(elem);\n  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];\n  return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\n\nexports.getNextSiblings = getNextSiblings;\n/*\n * :not, :has and :matches have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\n\nexports.subselects = {\n  /**\n   * `:is` is an alias for `:matches`.\n   */\n  is: function (next, token, options, context, compileToken) {\n    return exports.subselects.matches(next, token, options, context, compileToken);\n  },\n  matches: function (next, token, options, context, compileToken) {\n    var opts = {\n      xmlMode: !!options.xmlMode,\n      strict: !!options.strict,\n      adapter: options.adapter,\n      equals: options.equals,\n      rootFunc: next\n    };\n    return compileToken(token, opts, context);\n  },\n  not: function (next, token, options, context, compileToken) {\n    var opts = {\n      xmlMode: !!options.xmlMode,\n      strict: !!options.strict,\n      adapter: options.adapter,\n      equals: options.equals\n    };\n\n    if (opts.strict) {\n      if (token.length > 1 || token.some(containsTraversal)) {\n        throw new Error(\"complex selectors in :not aren't allowed in strict mode\");\n      }\n    }\n\n    var func = compileToken(token, opts, context);\n    if (func === boolbase_1.falseFunc) return next;\n    if (func === boolbase_1.trueFunc) return boolbase_1.falseFunc;\n    return function not(elem) {\n      return !func(elem) && next(elem);\n    };\n  },\n  has: function (next, subselect, options, _context, compileToken) {\n    var adapter = options.adapter;\n    var opts = {\n      xmlMode: !!options.xmlMode,\n      strict: !!options.strict,\n      adapter: adapter,\n      equals: options.equals\n    }; // @ts-expect-error Uses an array as a pointer to the current element (side effects)\n\n    var context = subselect.some(containsTraversal) ? [exports.PLACEHOLDER_ELEMENT] : undefined;\n    var compiled = compileToken(subselect, opts, context);\n    if (compiled === boolbase_1.falseFunc) return boolbase_1.falseFunc;\n\n    if (compiled === boolbase_1.trueFunc) {\n      return function (elem) {\n        return adapter.getChildren(elem).some(adapter.isTag) && next(elem);\n      };\n    }\n\n    var hasElement = ensureIsTag(compiled, adapter);\n    var _a = compiled.shouldTestNextSiblings,\n        shouldTestNextSiblings = _a === void 0 ? false : _a;\n    /*\n     * `shouldTestNextSiblings` will only be true if the query starts with\n     * a traversal (sibling or adjacent). That means we will always have a context.\n     */\n\n    if (context) {\n      return function (elem) {\n        context[0] = elem;\n        var childs = adapter.getChildren(elem);\n        var nextElements = shouldTestNextSiblings ? __spreadArrays(childs, getNextSiblings(elem, adapter)) : childs;\n        return next(elem) && adapter.existsOne(hasElement, nextElements);\n      };\n    }\n\n    return function (elem) {\n      return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));\n    };\n  }\n};","map":{"version":3,"sources":["/home/conrad/Documents/tarot/tarot-cards/node_modules/cheerio-select-tmp/node_modules/css-select/lib/pseudo-selectors/subselects.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","Object","defineProperty","exports","value","subselects","getNextSiblings","ensureIsTag","PLACEHOLDER_ELEMENT","boolbase_1","require","procedure_1","containsTraversal","t","some","isTraversal","next","adapter","falseFunc","elem","isTag","siblings","getSiblings","elemIndex","indexOf","slice","filter","is","token","options","context","compileToken","matches","opts","xmlMode","strict","equals","rootFunc","not","Error","func","trueFunc","has","subselect","_context","undefined","compiled","getChildren","hasElement","_a","shouldTestNextSiblings","childs","nextElements","existsOne"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;\nvar boolbase_1 = require(\"boolbase\");\nvar procedure_1 = require(\"../procedure\");\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexports.PLACEHOLDER_ELEMENT = {};\nfunction containsTraversal(t) {\n    return t.some(procedure_1.isTraversal);\n}\nfunction ensureIsTag(next, adapter) {\n    if (next === boolbase_1.falseFunc)\n        return next;\n    return function (elem) { return adapter.isTag(elem) && next(elem); };\n}\nexports.ensureIsTag = ensureIsTag;\nfunction getNextSiblings(elem, adapter) {\n    var siblings = adapter.getSiblings(elem);\n    if (siblings.length <= 1)\n        return [];\n    var elemIndex = siblings.indexOf(elem);\n    if (elemIndex < 0 || elemIndex === siblings.length - 1)\n        return [];\n    return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nexports.getNextSiblings = getNextSiblings;\n/*\n * :not, :has and :matches have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexports.subselects = {\n    /**\n     * `:is` is an alias for `:matches`.\n     */\n    is: function (next, token, options, context, compileToken) {\n        return exports.subselects.matches(next, token, options, context, compileToken);\n    },\n    matches: function (next, token, options, context, compileToken) {\n        var opts = {\n            xmlMode: !!options.xmlMode,\n            strict: !!options.strict,\n            adapter: options.adapter,\n            equals: options.equals,\n            rootFunc: next,\n        };\n        return compileToken(token, opts, context);\n    },\n    not: function (next, token, options, context, compileToken) {\n        var opts = {\n            xmlMode: !!options.xmlMode,\n            strict: !!options.strict,\n            adapter: options.adapter,\n            equals: options.equals,\n        };\n        if (opts.strict) {\n            if (token.length > 1 || token.some(containsTraversal)) {\n                throw new Error(\"complex selectors in :not aren't allowed in strict mode\");\n            }\n        }\n        var func = compileToken(token, opts, context);\n        if (func === boolbase_1.falseFunc)\n            return next;\n        if (func === boolbase_1.trueFunc)\n            return boolbase_1.falseFunc;\n        return function not(elem) {\n            return !func(elem) && next(elem);\n        };\n    },\n    has: function (next, subselect, options, _context, compileToken) {\n        var adapter = options.adapter;\n        var opts = {\n            xmlMode: !!options.xmlMode,\n            strict: !!options.strict,\n            adapter: adapter,\n            equals: options.equals,\n        };\n        // @ts-expect-error Uses an array as a pointer to the current element (side effects)\n        var context = subselect.some(containsTraversal)\n            ? [exports.PLACEHOLDER_ELEMENT]\n            : undefined;\n        var compiled = compileToken(subselect, opts, context);\n        if (compiled === boolbase_1.falseFunc)\n            return boolbase_1.falseFunc;\n        if (compiled === boolbase_1.trueFunc) {\n            return function (elem) {\n                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);\n            };\n        }\n        var hasElement = ensureIsTag(compiled, adapter);\n        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;\n        /*\n         * `shouldTestNextSiblings` will only be true if the query starts with\n         * a traversal (sibling or adjacent). That means we will always have a context.\n         */\n        if (context) {\n            return function (elem) {\n                context[0] = elem;\n                var childs = adapter.getChildren(elem);\n                var nextElements = shouldTestNextSiblings\n                    ? __spreadArrays(childs, getNextSiblings(elem, adapter)) : childs;\n                return (next(elem) && adapter.existsOne(hasElement, nextElements));\n            };\n        }\n        return function (elem) {\n            return next(elem) &&\n                adapter.existsOne(hasElement, adapter.getChildren(elem));\n        };\n    },\n};\n"]},"metadata":{},"sourceType":"script"}
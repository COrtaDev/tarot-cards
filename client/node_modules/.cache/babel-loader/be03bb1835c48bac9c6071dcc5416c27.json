{"ast":null,"code":"const request = require(\"./request.js\");\n\nconst RequestBase = require(\"./RequestBase.js\");\n\nconst url = require(\"url\");\n\nconst cleanJoin = require(\"./url.js\");\n\nconst {\n  mergeObjects,\n  isRedirect\n} = require(\"./utils/utils.js\");\n\nclass LadybugRequest extends RequestBase {\n  constructor(options = {}) {\n    super(options);\n    this.agent = options.agent || null; // TODO http/https custom agent support\n\n    this.method = options.method || \"GET\";\n    this.url = options.url;\n  }\n\n  then(resolve, reject) {\n    return request(this).then(res => {\n      // Redirects\n      // TODO maybe we need a bit extra handling for each redirect code?\n      // TODO redirect limits\n      // TODO option to turn on/off follow redirects\n      if (isRedirect(res.status) && res.headers.location) {\n        const options = cleanJoin(this); // url.format doesn't recognize path and port :(\n\n        options.pathname = options.path;\n        if (options.port) options.host = `${options.host}:${options.port}`;\n        const newURL = url.resolve(url.format(options), res.headers.location);\n        return new LadybugRequest(mergeObjects(request, {\n          url: newURL\n        }));\n      } else return res;\n    }).then(resolve, reject);\n  }\n\n  catch(callback) {\n    return this.then(undefined, callback);\n  }\n\n}\n\nmodule.exports = LadybugRequest;","map":{"version":3,"sources":["/home/conrad/Documents/tarot/tarot-cards/node_modules/ladybug-fetch/src/LadybugRequest.js"],"names":["request","require","RequestBase","url","cleanJoin","mergeObjects","isRedirect","LadybugRequest","constructor","options","agent","method","then","resolve","reject","res","status","headers","location","pathname","path","port","host","newURL","format","catch","callback","undefined","module","exports"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAD,CAAvB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,kBAAD,CAA3B;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,KAAD,CAAnB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,UAAD,CAAzB;;AACA,MAAM;AAAEI,EAAAA,YAAF;AAAgBC,EAAAA;AAAhB,IAA+BL,OAAO,CAAC,kBAAD,CAA5C;;AAEA,MAAMM,cAAN,SAA6BL,WAA7B,CAAyC;AACvCM,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACxB,UAAMA,OAAN;AACA,SAAKC,KAAL,GAAaD,OAAO,CAACC,KAAR,IAAiB,IAA9B,CAFwB,CAEY;;AACpC,SAAKC,MAAL,GAAcF,OAAO,CAACE,MAAR,IAAkB,KAAhC;AACA,SAAKR,GAAL,GAAWM,OAAO,CAACN,GAAnB;AACD;;AAEDS,EAAAA,IAAI,CAACC,OAAD,EAAUC,MAAV,EAAkB;AACpB,WAAOd,OAAO,CAAC,IAAD,CAAP,CACJY,IADI,CACEG,GAAD,IAAS;AACb;AACA;AACA;AACA;AACA,UAAGT,UAAU,CAACS,GAAG,CAACC,MAAL,CAAV,IAA0BD,GAAG,CAACE,OAAJ,CAAYC,QAAzC,EAAmD;AACjD,cAAMT,OAAO,GAAGL,SAAS,CAAC,IAAD,CAAzB,CADiD,CAGjD;;AACAK,QAAAA,OAAO,CAACU,QAAR,GAAmBV,OAAO,CAACW,IAA3B;AACA,YAAGX,OAAO,CAACY,IAAX,EAAiBZ,OAAO,CAACa,IAAR,GAAgB,GAAEb,OAAO,CAACa,IAAK,IAAGb,OAAO,CAACY,IAAK,EAA/C;AACjB,cAAME,MAAM,GAAGpB,GAAG,CAACU,OAAJ,CAAYV,GAAG,CAACqB,MAAJ,CAAWf,OAAX,CAAZ,EAAiCM,GAAG,CAACE,OAAJ,CAAYC,QAA7C,CAAf;AACA,eAAO,IAAIX,cAAJ,CAAmBF,YAAY,CAACL,OAAD,EAAU;AAAEG,UAAAA,GAAG,EAAEoB;AAAP,SAAV,CAA/B,CAAP;AACD,OARD,MAQO,OAAOR,GAAP;AACR,KAfI,EAgBJH,IAhBI,CAgBCC,OAhBD,EAgBUC,MAhBV,CAAP;AAiBD;;AAEDW,EAAAA,KAAK,CAACC,QAAD,EAAW;AACd,WAAO,KAAKd,IAAL,CAAUe,SAAV,EAAqBD,QAArB,CAAP;AACD;;AA9BsC;;AAiCzCE,MAAM,CAACC,OAAP,GAAiBtB,cAAjB","sourcesContent":["const request = require(\"./request.js\");\nconst RequestBase = require(\"./RequestBase.js\");\nconst url = require(\"url\");\nconst cleanJoin = require(\"./url.js\");\nconst { mergeObjects, isRedirect } = require(\"./utils/utils.js\");\n\nclass LadybugRequest extends RequestBase {\n  constructor(options = {}) {\n    super(options);\n    this.agent = options.agent || null; // TODO http/https custom agent support\n    this.method = options.method || \"GET\";\n    this.url = options.url;\n  }\n\n  then(resolve, reject) {\n    return request(this)\n      .then((res) => {\n        // Redirects\n        // TODO maybe we need a bit extra handling for each redirect code?\n        // TODO redirect limits\n        // TODO option to turn on/off follow redirects\n        if(isRedirect(res.status) && res.headers.location) {\n          const options = cleanJoin(this);\n\n          // url.format doesn't recognize path and port :(\n          options.pathname = options.path;\n          if(options.port) options.host = `${options.host}:${options.port}`;\n          const newURL = url.resolve(url.format(options), res.headers.location);\n          return new LadybugRequest(mergeObjects(request, { url: newURL }));\n        } else return res;\n      })\n      .then(resolve, reject);\n  }\n  \n  catch(callback) {\n    return this.then(undefined, callback);\n  }\n}\n\nmodule.exports = LadybugRequest;\n"]},"metadata":{},"sourceType":"script"}
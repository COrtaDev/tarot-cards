{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.Diff = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function Diff() {}\n\n  Diff.prototype = {\n    diff: function diff(oldString, newString) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = options.callback;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      this.options = options;\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function () {\n            callback(undefined, value);\n          }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      } // Allow subclasses to massage the input prior to running\n\n\n      oldString = this.castInput(oldString);\n      newString = this.castInput(newString);\n      oldString = this.removeEmpty(this.tokenize(oldString));\n      newString = this.removeEmpty(this.tokenize(newString));\n      var newLen = newString.length,\n          oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{\n        newPos: -1,\n        components: []\n      }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{\n          value: this.join(newString),\n          count: newString.length\n        }]);\n      } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath = void 0;\n\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          } // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n\n\n          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath; // No need to clone, we've pulled it from the list\n\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n\n\n      if (callback) {\n        (function exec() {\n          setTimeout(function () {\n            // This should not happen, but we want to be safe.\n\n            /* istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        })();\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n    pushComponent: function pushComponent(components, added, removed) {\n      var last = components[components.length - 1];\n\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {\n          count: last.count + 1,\n          added: added,\n          removed: removed\n        };\n      } else {\n        components.push({\n          count: 1,\n          added: added,\n          removed: removed\n        });\n      }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n          commonCount = 0;\n\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({\n          count: commonCount\n        });\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n    equals: function equals(left, right) {\n      if (this.options.comparator) {\n        return this.options.comparator(left, right);\n      } else {\n        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n      }\n    },\n    removeEmpty: function removeEmpty(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n\n      return ret;\n    },\n    castInput: function castInput(value) {\n      return value;\n    },\n    tokenize: function tokenize(value) {\n      return value.split('');\n    },\n    join: function join(chars) {\n      return chars.join('');\n    }\n  };\n\n  function buildValues(diff, components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = value.map(function (value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n          component.value = diff.join(value);\n        } else {\n          component.value = diff.join(newString.slice(newPos, newPos + component.count));\n        }\n\n        newPos += component.count; // Common case\n\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n\n\n    var lastComponent = components[componentLen - 1];\n\n    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n      components[componentLen - 2].value += lastComponent.value;\n      components.pop();\n    }\n\n    return components;\n  }\n\n  function clonePath(path) {\n    return {\n      newPos: path.newPos,\n      components: path.components.slice(0)\n    };\n  }\n\n  var characterDiff = new Diff();\n\n  function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n  }\n\n  function generateOptions(options, defaults) {\n    if (typeof options === 'function') {\n      defaults.callback = options;\n    } else if (options) {\n      for (var name in options) {\n        /* istanbul ignore else */\n        if (options.hasOwnProperty(name)) {\n          defaults[name] = options[name];\n        }\n      }\n    }\n\n    return defaults;\n  } //\n  // Ranges and exceptions:\n  // Latin-1 Supplement, 0080–00FF\n  //  - U+00D7  × Multiplication sign\n  //  - U+00F7  ÷ Division sign\n  // Latin Extended-A, 0100–017F\n  // Latin Extended-B, 0180–024F\n  // IPA Extensions, 0250–02AF\n  // Spacing Modifier Letters, 02B0–02FF\n  //  - U+02C7  ˇ &#711;  Caron\n  //  - U+02D8  ˘ &#728;  Breve\n  //  - U+02D9  ˙ &#729;  Dot Above\n  //  - U+02DA  ˚ &#730;  Ring Above\n  //  - U+02DB  ˛ &#731;  Ogonek\n  //  - U+02DC  ˜ &#732;  Small Tilde\n  //  - U+02DD  ˝ &#733;  Double Acute Accent\n  // Latin Extended Additional, 1E00–1EFF\n\n\n  var extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n  var reWhitespace = /\\S/;\n  var wordDiff = new Diff();\n\n  wordDiff.equals = function (left, right) {\n    if (this.options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n  };\n\n  wordDiff.tokenize = function (value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n    for (var i = 0; i < tokens.length - 1; i++) {\n      // If we have an empty string in the next field and we have only word chars before and after, merge\n      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n        tokens[i] += tokens[i + 2];\n        tokens.splice(i + 1, 2);\n        i--;\n      }\n    }\n\n    return tokens;\n  };\n\n  function diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n      ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  var lineDiff = new Diff();\n\n  lineDiff.tokenize = function (value) {\n    var retLines = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n\n\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2 && !this.options.newlineIsToken) {\n        retLines[retLines.length - 1] += line;\n      } else {\n        if (this.options.ignoreWhitespace) {\n          line = line.trim();\n        }\n\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  function diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n  }\n\n  function diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n      ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n  }\n\n  var sentenceDiff = new Diff();\n\n  sentenceDiff.tokenize = function (value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n  };\n\n  function diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n  }\n\n  var cssDiff = new Diff();\n\n  cssDiff.tokenize = function (value) {\n    return value.split(/([{}:;,]|\\s+)/);\n  };\n\n  function diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var objectPrototypeToString = Object.prototype.toString;\n  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n  jsonDiff.useLongestToken = true;\n  jsonDiff.tokenize = lineDiff.tokenize;\n\n  jsonDiff.castInput = function (value) {\n    var _this$options = this.options,\n        undefinedReplacement = _this$options.undefinedReplacement,\n        _this$options$stringi = _this$options.stringifyReplacer,\n        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n  };\n\n  jsonDiff.equals = function (left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  function diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n  } // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n\n  function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    if (replacer) {\n      obj = replacer(key, obj);\n    }\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n      return canonicalizedObj;\n    }\n\n    if (obj && obj.toJSON) {\n      obj = obj.toJSON();\n    }\n\n    if (_typeof(obj) === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n\n      var sortedKeys = [],\n          _key;\n\n      for (_key in obj) {\n        /* istanbul ignore else */\n        if (obj.hasOwnProperty(_key)) {\n          sortedKeys.push(_key);\n        }\n      }\n\n      sortedKeys.sort();\n\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        _key = sortedKeys[i];\n        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n\n    return canonicalizedObj;\n  }\n\n  var arrayDiff = new Diff();\n\n  arrayDiff.tokenize = function (value) {\n    return value.slice();\n  };\n\n  arrayDiff.join = arrayDiff.removeEmpty = function (value) {\n    return value;\n  };\n\n  function diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n  }\n\n  function parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        list = [],\n        i = 0;\n\n    function parseIndex() {\n      var index = {};\n      list.push(index); // Parse diff metadata\n\n      while (i < diffstr.length) {\n        var line = diffstr[i]; // File header found, end parsing diff metadata\n\n        if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n          break;\n        } // Diff index\n\n\n        var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n        if (header) {\n          index.index = header[1];\n        }\n\n        i++;\n      } // Parse file headers if they are defined. Unified diff requires them, but\n      // there's no technical issues to have an isolated hunk without file header\n\n\n      parseFileHeader(index);\n      parseFileHeader(index); // Parse hunks\n\n      index.hunks = [];\n\n      while (i < diffstr.length) {\n        var _line = diffstr[i];\n\n        if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n          break;\n        } else if (/^@@/.test(_line)) {\n          index.hunks.push(parseHunk());\n        } else if (_line && options.strict) {\n          // Ignore unexpected content unless in strict mode\n          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n        } else {\n          i++;\n        }\n      }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n\n\n    function parseFileHeader(index) {\n      var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n      if (fileHeader) {\n        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n        var data = fileHeader[2].split('\\t', 2);\n        var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n        if (/^\".*\"$/.test(fileName)) {\n          fileName = fileName.substr(1, fileName.length - 2);\n        }\n\n        index[keyPrefix + 'FileName'] = fileName;\n        index[keyPrefix + 'Header'] = (data[1] || '').trim();\n        i++;\n      }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n\n\n    function parseHunk() {\n      var chunkHeaderIndex = i,\n          chunkHeaderLine = diffstr[i++],\n          chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n      var hunk = {\n        oldStart: +chunkHeader[1],\n        oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n        newStart: +chunkHeader[3],\n        newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n        lines: [],\n        linedelimiters: []\n      }; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart += 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart += 1;\n      }\n\n      var addCount = 0,\n          removeCount = 0;\n\n      for (; i < diffstr.length; i++) {\n        // Lines starting with '---' could be mistaken for the \"remove line\" operation\n        // But they could be the header for the next file. Therefore prune such cases out.\n        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n        }\n\n        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n          hunk.lines.push(diffstr[i]);\n          hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n          if (operation === '+') {\n            addCount++;\n          } else if (operation === '-') {\n            removeCount++;\n          } else if (operation === ' ') {\n            addCount++;\n            removeCount++;\n          }\n        } else {\n          break;\n        }\n      } // Handle the empty block count case\n\n\n      if (!addCount && hunk.newLines === 1) {\n        hunk.newLines = 0;\n      }\n\n      if (!removeCount && hunk.oldLines === 1) {\n        hunk.oldLines = 0;\n      } // Perform optional sanity checking\n\n\n      if (options.strict) {\n        if (addCount !== hunk.newLines) {\n          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n\n        if (removeCount !== hunk.oldLines) {\n          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n      }\n\n      return hunk;\n    }\n\n    while (i < diffstr.length) {\n      parseIndex();\n    }\n\n    return list;\n  } // Iterator that traverses in the range of [min, max], stepping\n  // by distance from a given start position. I.e. for [0, 4], with\n  // start of 2, this will iterate 2, 3, 1, 4, 0.\n\n\n  function distanceIterator(start, minLine, maxLine) {\n    var wantForward = true,\n        backwardExhausted = false,\n        forwardExhausted = false,\n        localOffset = 1;\n    return function iterator() {\n      if (wantForward && !forwardExhausted) {\n        if (backwardExhausted) {\n          localOffset++;\n        } else {\n          wantForward = false;\n        } // Check if trying to fit beyond text length, and if not, check it fits\n        // after offset location (or desired location on first iteration)\n\n\n        if (start + localOffset <= maxLine) {\n          return localOffset;\n        }\n\n        forwardExhausted = true;\n      }\n\n      if (!backwardExhausted) {\n        if (!forwardExhausted) {\n          wantForward = true;\n        } // Check if trying to fit before text beginning, and if not, check it fits\n        // before offset location\n\n\n        if (minLine <= start - localOffset) {\n          return -localOffset++;\n        }\n\n        backwardExhausted = true;\n        return iterator();\n      } // We tried to fit hunk before text beginning and beyond text length, then\n      // hunk can't fit on the text. Return undefined\n\n    };\n  }\n\n  function applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    if (Array.isArray(uniDiff)) {\n      if (uniDiff.length > 1) {\n        throw new Error('applyPatch only works with a single input.');\n      }\n\n      uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n\n\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        hunks = uniDiff.hunks,\n        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n        errorCount = 0,\n        fuzzFactor = options.fuzzFactor || 0,\n        minLine = 0,\n        offset = 0,\n        removeEOFNL,\n        addEOFNL;\n    /**\n     * Checks if the hunk exactly fits on the provided location\n     */\n\n\n    function hunkFits(hunk, toPos) {\n      for (var j = 0; j < hunk.lines.length; j++) {\n        var line = hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line;\n\n        if (operation === ' ' || operation === '-') {\n          // Context sanity check\n          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n            errorCount++;\n\n            if (errorCount > fuzzFactor) {\n              return false;\n            }\n          }\n\n          toPos++;\n        }\n      }\n\n      return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n\n\n    for (var i = 0; i < hunks.length; i++) {\n      var hunk = hunks[i],\n          maxLine = lines.length - hunk.oldLines,\n          localOffset = 0,\n          toPos = offset + hunk.oldStart - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n\n      for (; localOffset !== undefined; localOffset = iterator()) {\n        if (hunkFits(hunk, toPos + localOffset)) {\n          hunk.offset = offset += localOffset;\n          break;\n        }\n      }\n\n      if (localOffset === undefined) {\n        return false;\n      } // Set lower text limit to end of the current hunk, so next ones don't try\n      // to fit over already patched text\n\n\n      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n\n\n    var diffOffset = 0;\n\n    for (var _i = 0; _i < hunks.length; _i++) {\n      var _hunk = hunks[_i],\n          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n      diffOffset += _hunk.newLines - _hunk.oldLines;\n\n      for (var j = 0; j < _hunk.lines.length; j++) {\n        var line = _hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line,\n            delimiter = _hunk.linedelimiters[j];\n\n        if (operation === ' ') {\n          _toPos++;\n        } else if (operation === '-') {\n          lines.splice(_toPos, 1);\n          delimiters.splice(_toPos, 1);\n          /* istanbul ignore else */\n        } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n    } // Handle EOFNL insertion/removal\n\n\n    if (removeEOFNL) {\n      while (!lines[lines.length - 1]) {\n        lines.pop();\n        delimiters.pop();\n      }\n    } else if (addEOFNL) {\n      lines.push('');\n      delimiters.push('\\n');\n    }\n\n    for (var _k = 0; _k < lines.length - 1; _k++) {\n      lines[_k] = lines[_k] + delimiters[_k];\n    }\n\n    return lines.join('');\n  } // Wrapper that supports multiple file patches via callbacks.\n\n\n  function applyPatches(uniDiff, options) {\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    var currentIndex = 0;\n\n    function processIndex() {\n      var index = uniDiff[currentIndex++];\n\n      if (!index) {\n        return options.complete();\n      }\n\n      options.loadFile(index, function (err, data) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        var updatedContent = applyPatch(data, index, options);\n        options.patched(index, updatedContent, function (err) {\n          if (err) {\n            return options.complete(err);\n          }\n\n          processIndex();\n        });\n      });\n    }\n\n    processIndex();\n  }\n\n  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof options.context === 'undefined') {\n      options.context = 4;\n    }\n\n    var diff = diffLines(oldStr, newStr, options);\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n\n    var hunks = [];\n    var oldRangeStart = 0,\n        newRangeStart = 0,\n        curRange = [],\n        oldLine = 1,\n        newLine = 1;\n\n    var _loop = function _loop(i) {\n      var current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        var _curRange; // If we have previous context, start with that\n\n\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        } // Output our changes\n\n\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        }))); // Track the updated file position\n\n\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2; // Overlapping\n\n\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n          } else {\n            var _curRange3; // end the range and output\n\n\n            var contextSize = Math.min(lines.length, options.context);\n\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n            var hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n\n            if (i >= diff.length - 2 && lines.length <= options.context) {\n              // EOF is inside this hunk\n              var oldEOFNewline = /\\n$/.test(oldStr);\n              var newEOFNewline = /\\n$/.test(newStr);\n              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n              if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                // special case: old has no eol and no trailing context; no-nl can end up before adds\n                // however, if the old file is empty, do not output the no-nl line\n                curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n              }\n\n              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                curRange.push('\\\\ No newline at end of file');\n              }\n            }\n\n            hunks.push(hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n\n    for (var i = 0; i < diff.length; i++) {\n      _loop(i);\n    }\n\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n\n  function formatPatch(diff) {\n    var ret = [];\n\n    if (diff.oldFileName == diff.newFileName) {\n      ret.push('Index: ' + diff.oldFileName);\n    }\n\n    ret.push('===================================================================');\n    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n    for (var i = 0; i < diff.hunks.length; i++) {\n      var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart -= 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart -= 1;\n      }\n\n      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n      ret.push.apply(ret, hunk.lines);\n    }\n\n    return ret.join('\\n') + '\\n';\n  }\n\n  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n  }\n\n  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n  }\n\n  function arrayEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return arrayStartsWith(a, b);\n  }\n\n  function arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n      return false;\n    }\n\n    for (var i = 0; i < start.length; i++) {\n      if (start[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n        oldLines = _calcOldNewLineCount.oldLines,\n        newLines = _calcOldNewLineCount.newLines;\n\n    if (oldLines !== undefined) {\n      hunk.oldLines = oldLines;\n    } else {\n      delete hunk.oldLines;\n    }\n\n    if (newLines !== undefined) {\n      hunk.newLines = newLines;\n    } else {\n      delete hunk.newLines;\n    }\n  }\n\n  function merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n\n    if (mine.index || theirs.index) {\n      ret.index = mine.index || theirs.index;\n    }\n\n    if (mine.newFileName || theirs.newFileName) {\n      if (!fileNameChanged(mine)) {\n        // No header or no change in ours, use theirs (and ours if theirs does not exist)\n        ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n        ret.newFileName = theirs.newFileName || mine.newFileName;\n        ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n        ret.newHeader = theirs.newHeader || mine.newHeader;\n      } else if (!fileNameChanged(theirs)) {\n        // No header or no change in theirs, use ours\n        ret.oldFileName = mine.oldFileName;\n        ret.newFileName = mine.newFileName;\n        ret.oldHeader = mine.oldHeader;\n        ret.newHeader = mine.newHeader;\n      } else {\n        // Both changed... figure it out\n        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n      }\n    }\n\n    ret.hunks = [];\n    var mineIndex = 0,\n        theirsIndex = 0,\n        mineOffset = 0,\n        theirsOffset = 0;\n\n    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n      var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n          theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n\n      if (hunkBefore(mineCurrent, theirsCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n        mineIndex++;\n        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n      } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n        theirsIndex++;\n        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n      } else {\n        // Overlap, merge as best we can\n        var mergedHunk = {\n          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n          oldLines: 0,\n          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n          newLines: 0,\n          lines: []\n        };\n        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n        theirsIndex++;\n        mineIndex++;\n        ret.hunks.push(mergedHunk);\n      }\n    }\n\n    return ret;\n  }\n\n  function loadPatch(param, base) {\n    if (typeof param === 'string') {\n      if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n        return parsePatch(param)[0];\n      }\n\n      if (!base) {\n        throw new Error('Must provide a base reference or pass in a patch');\n      }\n\n      return structuredPatch(undefined, undefined, base, param);\n    }\n\n    return param;\n  }\n\n  function fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n  }\n\n  function selectField(index, mine, theirs) {\n    if (mine === theirs) {\n      return mine;\n    } else {\n      index.conflict = true;\n      return {\n        mine: mine,\n        theirs: theirs\n      };\n    }\n  }\n\n  function hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n  }\n\n  function cloneHunk(hunk, offset) {\n    return {\n      oldStart: hunk.oldStart,\n      oldLines: hunk.oldLines,\n      newStart: hunk.newStart + offset,\n      newLines: hunk.newLines,\n      lines: hunk.lines\n    };\n  }\n\n  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n        their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    }; // Handle any leading content\n\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n    while (mine.index < mine.lines.length && their.index < their.lines.length) {\n      var mineCurrent = mine.lines[mine.index],\n          theirCurrent = their.lines[their.index];\n\n      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n        // Both modified ...\n        mutualChange(hunk, mine, their);\n      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n        var _hunk$lines; // Mine inserted\n\n\n        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n        var _hunk$lines2; // Theirs inserted\n\n\n        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n        // Mine removed or edited\n        removal(hunk, mine, their);\n      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n        // Their removed or edited\n        removal(hunk, their, mine, true);\n      } else if (mineCurrent === theirCurrent) {\n        // Context identity\n        hunk.lines.push(mineCurrent);\n        mine.index++;\n        their.index++;\n      } else {\n        // Context mismatch\n        conflict(hunk, collectChange(mine), collectChange(their));\n      }\n    } // Now push anything that may be remaining\n\n\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n  }\n\n  function mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectChange(their);\n\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n      // Special case for remove changes that are supersets of one another\n      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n        var _hunk$lines3;\n\n        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n        return;\n      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n        var _hunk$lines4;\n\n        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n        return;\n      }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n      var _hunk$lines5;\n\n      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n      return;\n    }\n\n    conflict(hunk, myChanges, theirChanges);\n  }\n\n  function removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectContext(their, myChanges);\n\n    if (theirChanges.merged) {\n      var _hunk$lines6;\n\n      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n  }\n\n  function conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n      conflict: true,\n      mine: mine,\n      theirs: their\n    });\n  }\n\n  function insertLeading(hunk, insert, their) {\n    while (insert.offset < their.offset && insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n      insert.offset++;\n    }\n  }\n\n  function insertTrailing(hunk, insert) {\n    while (insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n    }\n  }\n\n  function collectChange(state) {\n    var ret = [],\n        operation = state.lines[state.index][0];\n\n    while (state.index < state.lines.length) {\n      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n      if (operation === '-' && line[0] === '+') {\n        operation = '+';\n      }\n\n      if (operation === line[0]) {\n        ret.push(line);\n        state.index++;\n      } else {\n        break;\n      }\n    }\n\n    return ret;\n  }\n\n  function collectContext(state, matchChanges) {\n    var changes = [],\n        merged = [],\n        matchIndex = 0,\n        contextChanges = false,\n        conflicted = false;\n\n    while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n      var change = state.lines[state.index],\n          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n      if (match[0] === '+') {\n        break;\n      }\n\n      contextChanges = contextChanges || change[0] !== ' ';\n      merged.push(match);\n      matchIndex++; // Consume any additions in the other block as a conflict to attempt\n      // to pull in the remaining context after this\n\n      if (change[0] === '+') {\n        conflicted = true;\n\n        while (change[0] === '+') {\n          changes.push(change);\n          change = state.lines[++state.index];\n        }\n      }\n\n      if (match.substr(1) === change.substr(1)) {\n        changes.push(change);\n        state.index++;\n      } else {\n        conflicted = true;\n      }\n    }\n\n    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n      conflicted = true;\n    }\n\n    if (conflicted) {\n      return changes;\n    }\n\n    while (matchIndex < matchChanges.length) {\n      merged.push(matchChanges[matchIndex++]);\n    }\n\n    return {\n      merged: merged,\n      changes: changes\n    };\n  }\n\n  function allRemoves(changes) {\n    return changes.reduce(function (prev, change) {\n      return prev && change[0] === '-';\n    }, true);\n  }\n\n  function skipRemoveSuperset(state, removeChanges, delta) {\n    for (var i = 0; i < delta; i++) {\n      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n      if (state.lines[state.index + i] !== ' ' + changeContent) {\n        return false;\n      }\n    }\n\n    state.index += delta;\n    return true;\n  }\n\n  function calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function (line) {\n      if (typeof line !== 'string') {\n        var myCount = calcOldNewLineCount(line.mine);\n        var theirCount = calcOldNewLineCount(line.theirs);\n\n        if (oldLines !== undefined) {\n          if (myCount.oldLines === theirCount.oldLines) {\n            oldLines += myCount.oldLines;\n          } else {\n            oldLines = undefined;\n          }\n        }\n\n        if (newLines !== undefined) {\n          if (myCount.newLines === theirCount.newLines) {\n            newLines += myCount.newLines;\n          } else {\n            newLines = undefined;\n          }\n        }\n      } else {\n        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n          newLines++;\n        }\n\n        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n          oldLines++;\n        }\n      }\n    });\n    return {\n      oldLines: oldLines,\n      newLines: newLines\n    };\n  } // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n\n\n  function convertChangesToDMP(changes) {\n    var ret = [],\n        change,\n        operation;\n\n    for (var i = 0; i < changes.length; i++) {\n      change = changes[i];\n\n      if (change.added) {\n        operation = 1;\n      } else if (change.removed) {\n        operation = -1;\n      } else {\n        operation = 0;\n      }\n\n      ret.push([operation, change.value]);\n    }\n\n    return ret;\n  }\n\n  function convertChangesToXML(changes) {\n    var ret = [];\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (change.added) {\n        ret.push('<ins>');\n      } else if (change.removed) {\n        ret.push('<del>');\n      }\n\n      ret.push(escapeHTML(change.value));\n\n      if (change.added) {\n        ret.push('</ins>');\n      } else if (change.removed) {\n        ret.push('</del>');\n      }\n    }\n\n    return ret.join('');\n  }\n\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n    return n;\n  }\n\n  exports.Diff = Diff;\n  exports.applyPatch = applyPatch;\n  exports.applyPatches = applyPatches;\n  exports.canonicalize = canonicalize;\n  exports.convertChangesToDMP = convertChangesToDMP;\n  exports.convertChangesToXML = convertChangesToXML;\n  exports.createPatch = createPatch;\n  exports.createTwoFilesPatch = createTwoFilesPatch;\n  exports.diffArrays = diffArrays;\n  exports.diffChars = diffChars;\n  exports.diffCss = diffCss;\n  exports.diffJson = diffJson;\n  exports.diffLines = diffLines;\n  exports.diffSentences = diffSentences;\n  exports.diffTrimmedLines = diffTrimmedLines;\n  exports.diffWords = diffWords;\n  exports.diffWordsWithSpace = diffWordsWithSpace;\n  exports.merge = merge;\n  exports.parsePatch = parsePatch;\n  exports.structuredPatch = structuredPatch;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/home/conrad/Documents/tarot/tarot-cards/node_modules/diff/dist/diff.js"],"names":["global","factory","exports","module","define","amd","self","Diff","prototype","diff","oldString","newString","options","arguments","length","undefined","callback","done","value","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","extractCommon","join","count","execEditLength","diagonalPath","basePath","addPath","removePath","_oldPos","canAdd","canRemove","clonePath","pushComponent","buildValues","useLongestToken","exec","ret","added","removed","last","push","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","split","chars","componentPos","componentLen","component","slice","map","oldValue","tmp","lastComponent","pop","path","characterDiff","diffChars","oldStr","newStr","generateOptions","defaults","name","hasOwnProperty","extendedWordChars","reWhitespace","wordDiff","ignoreWhitespace","test","tokens","splice","diffWords","diffWordsWithSpace","lineDiff","retLines","linesAndNewlines","line","newlineIsToken","trim","diffLines","diffTrimmedLines","sentenceDiff","diffSentences","cssDiff","diffCss","_typeof","obj","Symbol","iterator","constructor","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Object","from","o","minLen","n","toString","call","len","arr2","TypeError","objectPrototypeToString","jsonDiff","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","k","v","JSON","stringify","canonicalize","replace","diffJson","oldObj","newObj","stack","replacementStack","replacer","key","canonicalizedObj","toJSON","sortedKeys","_key","sort","arrayDiff","diffArrays","oldArr","newArr","parsePatch","uniDiff","diffstr","delimiters","match","list","parseIndex","index","header","parseFileHeader","hunks","_line","parseHunk","strict","Error","fileHeader","keyPrefix","data","fileName","substr","chunkHeaderIndex","chunkHeaderLine","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","indexOf","operation","distanceIterator","start","minLine","maxLine","wantForward","backwardExhausted","forwardExhausted","localOffset","applyPatch","source","compareLine","lineNumber","patchContent","errorCount","fuzzFactor","offset","removeEOFNL","addEOFNL","hunkFits","toPos","j","content","diffOffset","_i","_hunk","_toPos","delimiter","previousOperation","_k","applyPatches","currentIndex","processIndex","complete","loadFile","err","updatedContent","patched","structuredPatch","oldFileName","newFileName","oldHeader","newHeader","context","contextLines","entry","oldRangeStart","newRangeStart","curRange","oldLine","newLine","_loop","current","_curRange","prev","apply","_curRange2","_curRange3","contextSize","Math","min","oldEOFNewline","newEOFNewline","noNlBeforeAdds","formatPatch","createTwoFilesPatch","createPatch","arrayEqual","a","b","arrayStartsWith","calcLineCount","_calcOldNewLineCount","calcOldNewLineCount","merge","mine","theirs","base","loadPatch","fileNameChanged","selectField","mineIndex","theirsIndex","mineOffset","theirsOffset","mineCurrent","Infinity","theirsCurrent","hunkBefore","cloneHunk","mergedHunk","mergeLines","param","patch","conflict","check","mineLines","theirOffset","theirLines","their","insertLeading","theirCurrent","mutualChange","_hunk$lines","collectChange","_hunk$lines2","removal","insertTrailing","myChanges","theirChanges","allRemoves","skipRemoveSuperset","_hunk$lines3","_hunk$lines4","_hunk$lines5","swap","collectContext","merged","_hunk$lines6","insert","state","matchChanges","changes","matchIndex","contextChanges","conflicted","change","reduce","removeChanges","delta","changeContent","forEach","myCount","theirCount","convertChangesToDMP","convertChangesToXML","escapeHTML","s","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.Diff = {}));\n}(this, (function (exports) { 'use strict';\n\n  function Diff() {}\n  Diff.prototype = {\n    diff: function diff(oldString, newString) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = options.callback;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      this.options = options;\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function () {\n            callback(undefined, value);\n          }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      } // Allow subclasses to massage the input prior to running\n\n\n      oldString = this.castInput(oldString);\n      newString = this.castInput(newString);\n      oldString = this.removeEmpty(this.tokenize(oldString));\n      newString = this.removeEmpty(this.tokenize(newString));\n      var newLen = newString.length,\n          oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{\n        newPos: -1,\n        components: []\n      }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{\n          value: this.join(newString),\n          count: newString.length\n        }]);\n      } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath = void 0;\n\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          } // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n\n\n          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath; // No need to clone, we've pulled it from the list\n\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n\n\n      if (callback) {\n        (function exec() {\n          setTimeout(function () {\n            // This should not happen, but we want to be safe.\n\n            /* istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        })();\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n    pushComponent: function pushComponent(components, added, removed) {\n      var last = components[components.length - 1];\n\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {\n          count: last.count + 1,\n          added: added,\n          removed: removed\n        };\n      } else {\n        components.push({\n          count: 1,\n          added: added,\n          removed: removed\n        });\n      }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n          commonCount = 0;\n\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({\n          count: commonCount\n        });\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n    equals: function equals(left, right) {\n      if (this.options.comparator) {\n        return this.options.comparator(left, right);\n      } else {\n        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n      }\n    },\n    removeEmpty: function removeEmpty(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n\n      return ret;\n    },\n    castInput: function castInput(value) {\n      return value;\n    },\n    tokenize: function tokenize(value) {\n      return value.split('');\n    },\n    join: function join(chars) {\n      return chars.join('');\n    }\n  };\n\n  function buildValues(diff, components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = value.map(function (value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n          component.value = diff.join(value);\n        } else {\n          component.value = diff.join(newString.slice(newPos, newPos + component.count));\n        }\n\n        newPos += component.count; // Common case\n\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n\n\n    var lastComponent = components[componentLen - 1];\n\n    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n      components[componentLen - 2].value += lastComponent.value;\n      components.pop();\n    }\n\n    return components;\n  }\n\n  function clonePath(path) {\n    return {\n      newPos: path.newPos,\n      components: path.components.slice(0)\n    };\n  }\n\n  var characterDiff = new Diff();\n  function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n  }\n\n  function generateOptions(options, defaults) {\n    if (typeof options === 'function') {\n      defaults.callback = options;\n    } else if (options) {\n      for (var name in options) {\n        /* istanbul ignore else */\n        if (options.hasOwnProperty(name)) {\n          defaults[name] = options[name];\n        }\n      }\n    }\n\n    return defaults;\n  }\n\n  //\n  // Ranges and exceptions:\n  // Latin-1 Supplement, 0080–00FF\n  //  - U+00D7  × Multiplication sign\n  //  - U+00F7  ÷ Division sign\n  // Latin Extended-A, 0100–017F\n  // Latin Extended-B, 0180–024F\n  // IPA Extensions, 0250–02AF\n  // Spacing Modifier Letters, 02B0–02FF\n  //  - U+02C7  ˇ &#711;  Caron\n  //  - U+02D8  ˘ &#728;  Breve\n  //  - U+02D9  ˙ &#729;  Dot Above\n  //  - U+02DA  ˚ &#730;  Ring Above\n  //  - U+02DB  ˛ &#731;  Ogonek\n  //  - U+02DC  ˜ &#732;  Small Tilde\n  //  - U+02DD  ˝ &#733;  Double Acute Accent\n  // Latin Extended Additional, 1E00–1EFF\n\n  var extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n  var reWhitespace = /\\S/;\n  var wordDiff = new Diff();\n\n  wordDiff.equals = function (left, right) {\n    if (this.options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n  };\n\n  wordDiff.tokenize = function (value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n    for (var i = 0; i < tokens.length - 1; i++) {\n      // If we have an empty string in the next field and we have only word chars before and after, merge\n      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n        tokens[i] += tokens[i + 2];\n        tokens.splice(i + 1, 2);\n        i--;\n      }\n    }\n\n    return tokens;\n  };\n\n  function diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n      ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n  function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  var lineDiff = new Diff();\n\n  lineDiff.tokenize = function (value) {\n    var retLines = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n\n\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2 && !this.options.newlineIsToken) {\n        retLines[retLines.length - 1] += line;\n      } else {\n        if (this.options.ignoreWhitespace) {\n          line = line.trim();\n        }\n\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  function diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n  }\n  function diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n      ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n  }\n\n  var sentenceDiff = new Diff();\n\n  sentenceDiff.tokenize = function (value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n  };\n\n  function diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n  }\n\n  var cssDiff = new Diff();\n\n  cssDiff.tokenize = function (value) {\n    return value.split(/([{}:;,]|\\s+)/);\n  };\n\n  function diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var objectPrototypeToString = Object.prototype.toString;\n  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n  jsonDiff.useLongestToken = true;\n  jsonDiff.tokenize = lineDiff.tokenize;\n\n  jsonDiff.castInput = function (value) {\n    var _this$options = this.options,\n        undefinedReplacement = _this$options.undefinedReplacement,\n        _this$options$stringi = _this$options.stringifyReplacer,\n        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n  };\n\n  jsonDiff.equals = function (left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  function diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n  } // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n  function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    if (replacer) {\n      obj = replacer(key, obj);\n    }\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n      return canonicalizedObj;\n    }\n\n    if (obj && obj.toJSON) {\n      obj = obj.toJSON();\n    }\n\n    if (_typeof(obj) === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n\n      var sortedKeys = [],\n          _key;\n\n      for (_key in obj) {\n        /* istanbul ignore else */\n        if (obj.hasOwnProperty(_key)) {\n          sortedKeys.push(_key);\n        }\n      }\n\n      sortedKeys.sort();\n\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        _key = sortedKeys[i];\n        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n\n    return canonicalizedObj;\n  }\n\n  var arrayDiff = new Diff();\n\n  arrayDiff.tokenize = function (value) {\n    return value.slice();\n  };\n\n  arrayDiff.join = arrayDiff.removeEmpty = function (value) {\n    return value;\n  };\n\n  function diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n  }\n\n  function parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        list = [],\n        i = 0;\n\n    function parseIndex() {\n      var index = {};\n      list.push(index); // Parse diff metadata\n\n      while (i < diffstr.length) {\n        var line = diffstr[i]; // File header found, end parsing diff metadata\n\n        if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n          break;\n        } // Diff index\n\n\n        var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n        if (header) {\n          index.index = header[1];\n        }\n\n        i++;\n      } // Parse file headers if they are defined. Unified diff requires them, but\n      // there's no technical issues to have an isolated hunk without file header\n\n\n      parseFileHeader(index);\n      parseFileHeader(index); // Parse hunks\n\n      index.hunks = [];\n\n      while (i < diffstr.length) {\n        var _line = diffstr[i];\n\n        if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n          break;\n        } else if (/^@@/.test(_line)) {\n          index.hunks.push(parseHunk());\n        } else if (_line && options.strict) {\n          // Ignore unexpected content unless in strict mode\n          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n        } else {\n          i++;\n        }\n      }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n\n\n    function parseFileHeader(index) {\n      var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n      if (fileHeader) {\n        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n        var data = fileHeader[2].split('\\t', 2);\n        var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n        if (/^\".*\"$/.test(fileName)) {\n          fileName = fileName.substr(1, fileName.length - 2);\n        }\n\n        index[keyPrefix + 'FileName'] = fileName;\n        index[keyPrefix + 'Header'] = (data[1] || '').trim();\n        i++;\n      }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n\n\n    function parseHunk() {\n      var chunkHeaderIndex = i,\n          chunkHeaderLine = diffstr[i++],\n          chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n      var hunk = {\n        oldStart: +chunkHeader[1],\n        oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n        newStart: +chunkHeader[3],\n        newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n        lines: [],\n        linedelimiters: []\n      }; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart += 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart += 1;\n      }\n\n      var addCount = 0,\n          removeCount = 0;\n\n      for (; i < diffstr.length; i++) {\n        // Lines starting with '---' could be mistaken for the \"remove line\" operation\n        // But they could be the header for the next file. Therefore prune such cases out.\n        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n        }\n\n        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n          hunk.lines.push(diffstr[i]);\n          hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n          if (operation === '+') {\n            addCount++;\n          } else if (operation === '-') {\n            removeCount++;\n          } else if (operation === ' ') {\n            addCount++;\n            removeCount++;\n          }\n        } else {\n          break;\n        }\n      } // Handle the empty block count case\n\n\n      if (!addCount && hunk.newLines === 1) {\n        hunk.newLines = 0;\n      }\n\n      if (!removeCount && hunk.oldLines === 1) {\n        hunk.oldLines = 0;\n      } // Perform optional sanity checking\n\n\n      if (options.strict) {\n        if (addCount !== hunk.newLines) {\n          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n\n        if (removeCount !== hunk.oldLines) {\n          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n      }\n\n      return hunk;\n    }\n\n    while (i < diffstr.length) {\n      parseIndex();\n    }\n\n    return list;\n  }\n\n  // Iterator that traverses in the range of [min, max], stepping\n  // by distance from a given start position. I.e. for [0, 4], with\n  // start of 2, this will iterate 2, 3, 1, 4, 0.\n  function distanceIterator (start, minLine, maxLine) {\n    var wantForward = true,\n        backwardExhausted = false,\n        forwardExhausted = false,\n        localOffset = 1;\n    return function iterator() {\n      if (wantForward && !forwardExhausted) {\n        if (backwardExhausted) {\n          localOffset++;\n        } else {\n          wantForward = false;\n        } // Check if trying to fit beyond text length, and if not, check it fits\n        // after offset location (or desired location on first iteration)\n\n\n        if (start + localOffset <= maxLine) {\n          return localOffset;\n        }\n\n        forwardExhausted = true;\n      }\n\n      if (!backwardExhausted) {\n        if (!forwardExhausted) {\n          wantForward = true;\n        } // Check if trying to fit before text beginning, and if not, check it fits\n        // before offset location\n\n\n        if (minLine <= start - localOffset) {\n          return -localOffset++;\n        }\n\n        backwardExhausted = true;\n        return iterator();\n      } // We tried to fit hunk before text beginning and beyond text length, then\n      // hunk can't fit on the text. Return undefined\n\n    };\n  }\n\n  function applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    if (Array.isArray(uniDiff)) {\n      if (uniDiff.length > 1) {\n        throw new Error('applyPatch only works with a single input.');\n      }\n\n      uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n\n\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        hunks = uniDiff.hunks,\n        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n        errorCount = 0,\n        fuzzFactor = options.fuzzFactor || 0,\n        minLine = 0,\n        offset = 0,\n        removeEOFNL,\n        addEOFNL;\n    /**\n     * Checks if the hunk exactly fits on the provided location\n     */\n\n\n    function hunkFits(hunk, toPos) {\n      for (var j = 0; j < hunk.lines.length; j++) {\n        var line = hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line;\n\n        if (operation === ' ' || operation === '-') {\n          // Context sanity check\n          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n            errorCount++;\n\n            if (errorCount > fuzzFactor) {\n              return false;\n            }\n          }\n\n          toPos++;\n        }\n      }\n\n      return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n\n\n    for (var i = 0; i < hunks.length; i++) {\n      var hunk = hunks[i],\n          maxLine = lines.length - hunk.oldLines,\n          localOffset = 0,\n          toPos = offset + hunk.oldStart - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n\n      for (; localOffset !== undefined; localOffset = iterator()) {\n        if (hunkFits(hunk, toPos + localOffset)) {\n          hunk.offset = offset += localOffset;\n          break;\n        }\n      }\n\n      if (localOffset === undefined) {\n        return false;\n      } // Set lower text limit to end of the current hunk, so next ones don't try\n      // to fit over already patched text\n\n\n      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n\n\n    var diffOffset = 0;\n\n    for (var _i = 0; _i < hunks.length; _i++) {\n      var _hunk = hunks[_i],\n          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n      diffOffset += _hunk.newLines - _hunk.oldLines;\n\n      for (var j = 0; j < _hunk.lines.length; j++) {\n        var line = _hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line,\n            delimiter = _hunk.linedelimiters[j];\n\n        if (operation === ' ') {\n          _toPos++;\n        } else if (operation === '-') {\n          lines.splice(_toPos, 1);\n          delimiters.splice(_toPos, 1);\n          /* istanbul ignore else */\n        } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n    } // Handle EOFNL insertion/removal\n\n\n    if (removeEOFNL) {\n      while (!lines[lines.length - 1]) {\n        lines.pop();\n        delimiters.pop();\n      }\n    } else if (addEOFNL) {\n      lines.push('');\n      delimiters.push('\\n');\n    }\n\n    for (var _k = 0; _k < lines.length - 1; _k++) {\n      lines[_k] = lines[_k] + delimiters[_k];\n    }\n\n    return lines.join('');\n  } // Wrapper that supports multiple file patches via callbacks.\n\n  function applyPatches(uniDiff, options) {\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    var currentIndex = 0;\n\n    function processIndex() {\n      var index = uniDiff[currentIndex++];\n\n      if (!index) {\n        return options.complete();\n      }\n\n      options.loadFile(index, function (err, data) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        var updatedContent = applyPatch(data, index, options);\n        options.patched(index, updatedContent, function (err) {\n          if (err) {\n            return options.complete(err);\n          }\n\n          processIndex();\n        });\n      });\n    }\n\n    processIndex();\n  }\n\n  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof options.context === 'undefined') {\n      options.context = 4;\n    }\n\n    var diff = diffLines(oldStr, newStr, options);\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n\n    var hunks = [];\n    var oldRangeStart = 0,\n        newRangeStart = 0,\n        curRange = [],\n        oldLine = 1,\n        newLine = 1;\n\n    var _loop = function _loop(i) {\n      var current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        var _curRange;\n\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        } // Output our changes\n\n\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        }))); // Track the updated file position\n\n\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2;\n\n            // Overlapping\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n          } else {\n            var _curRange3;\n\n            // end the range and output\n            var contextSize = Math.min(lines.length, options.context);\n\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n            var hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n\n            if (i >= diff.length - 2 && lines.length <= options.context) {\n              // EOF is inside this hunk\n              var oldEOFNewline = /\\n$/.test(oldStr);\n              var newEOFNewline = /\\n$/.test(newStr);\n              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n              if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                // special case: old has no eol and no trailing context; no-nl can end up before adds\n                // however, if the old file is empty, do not output the no-nl line\n                curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n              }\n\n              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                curRange.push('\\\\ No newline at end of file');\n              }\n            }\n\n            hunks.push(hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n\n    for (var i = 0; i < diff.length; i++) {\n      _loop(i);\n    }\n\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n  function formatPatch(diff) {\n    var ret = [];\n\n    if (diff.oldFileName == diff.newFileName) {\n      ret.push('Index: ' + diff.oldFileName);\n    }\n\n    ret.push('===================================================================');\n    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n    for (var i = 0; i < diff.hunks.length; i++) {\n      var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart -= 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart -= 1;\n      }\n\n      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n      ret.push.apply(ret, hunk.lines);\n    }\n\n    return ret.join('\\n') + '\\n';\n  }\n  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n  }\n  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n  }\n\n  function arrayEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return arrayStartsWith(a, b);\n  }\n  function arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n      return false;\n    }\n\n    for (var i = 0; i < start.length; i++) {\n      if (start[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n        oldLines = _calcOldNewLineCount.oldLines,\n        newLines = _calcOldNewLineCount.newLines;\n\n    if (oldLines !== undefined) {\n      hunk.oldLines = oldLines;\n    } else {\n      delete hunk.oldLines;\n    }\n\n    if (newLines !== undefined) {\n      hunk.newLines = newLines;\n    } else {\n      delete hunk.newLines;\n    }\n  }\n  function merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n\n    if (mine.index || theirs.index) {\n      ret.index = mine.index || theirs.index;\n    }\n\n    if (mine.newFileName || theirs.newFileName) {\n      if (!fileNameChanged(mine)) {\n        // No header or no change in ours, use theirs (and ours if theirs does not exist)\n        ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n        ret.newFileName = theirs.newFileName || mine.newFileName;\n        ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n        ret.newHeader = theirs.newHeader || mine.newHeader;\n      } else if (!fileNameChanged(theirs)) {\n        // No header or no change in theirs, use ours\n        ret.oldFileName = mine.oldFileName;\n        ret.newFileName = mine.newFileName;\n        ret.oldHeader = mine.oldHeader;\n        ret.newHeader = mine.newHeader;\n      } else {\n        // Both changed... figure it out\n        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n      }\n    }\n\n    ret.hunks = [];\n    var mineIndex = 0,\n        theirsIndex = 0,\n        mineOffset = 0,\n        theirsOffset = 0;\n\n    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n      var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n          theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n\n      if (hunkBefore(mineCurrent, theirsCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n        mineIndex++;\n        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n      } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n        theirsIndex++;\n        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n      } else {\n        // Overlap, merge as best we can\n        var mergedHunk = {\n          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n          oldLines: 0,\n          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n          newLines: 0,\n          lines: []\n        };\n        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n        theirsIndex++;\n        mineIndex++;\n        ret.hunks.push(mergedHunk);\n      }\n    }\n\n    return ret;\n  }\n\n  function loadPatch(param, base) {\n    if (typeof param === 'string') {\n      if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n        return parsePatch(param)[0];\n      }\n\n      if (!base) {\n        throw new Error('Must provide a base reference or pass in a patch');\n      }\n\n      return structuredPatch(undefined, undefined, base, param);\n    }\n\n    return param;\n  }\n\n  function fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n  }\n\n  function selectField(index, mine, theirs) {\n    if (mine === theirs) {\n      return mine;\n    } else {\n      index.conflict = true;\n      return {\n        mine: mine,\n        theirs: theirs\n      };\n    }\n  }\n\n  function hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n  }\n\n  function cloneHunk(hunk, offset) {\n    return {\n      oldStart: hunk.oldStart,\n      oldLines: hunk.oldLines,\n      newStart: hunk.newStart + offset,\n      newLines: hunk.newLines,\n      lines: hunk.lines\n    };\n  }\n\n  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n        their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    }; // Handle any leading content\n\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n    while (mine.index < mine.lines.length && their.index < their.lines.length) {\n      var mineCurrent = mine.lines[mine.index],\n          theirCurrent = their.lines[their.index];\n\n      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n        // Both modified ...\n        mutualChange(hunk, mine, their);\n      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n        var _hunk$lines;\n\n        // Mine inserted\n        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n        var _hunk$lines2;\n\n        // Theirs inserted\n        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n        // Mine removed or edited\n        removal(hunk, mine, their);\n      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n        // Their removed or edited\n        removal(hunk, their, mine, true);\n      } else if (mineCurrent === theirCurrent) {\n        // Context identity\n        hunk.lines.push(mineCurrent);\n        mine.index++;\n        their.index++;\n      } else {\n        // Context mismatch\n        conflict(hunk, collectChange(mine), collectChange(their));\n      }\n    } // Now push anything that may be remaining\n\n\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n  }\n\n  function mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectChange(their);\n\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n      // Special case for remove changes that are supersets of one another\n      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n        var _hunk$lines3;\n\n        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n        return;\n      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n        var _hunk$lines4;\n\n        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n        return;\n      }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n      var _hunk$lines5;\n\n      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n      return;\n    }\n\n    conflict(hunk, myChanges, theirChanges);\n  }\n\n  function removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectContext(their, myChanges);\n\n    if (theirChanges.merged) {\n      var _hunk$lines6;\n\n      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n  }\n\n  function conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n      conflict: true,\n      mine: mine,\n      theirs: their\n    });\n  }\n\n  function insertLeading(hunk, insert, their) {\n    while (insert.offset < their.offset && insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n      insert.offset++;\n    }\n  }\n\n  function insertTrailing(hunk, insert) {\n    while (insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n    }\n  }\n\n  function collectChange(state) {\n    var ret = [],\n        operation = state.lines[state.index][0];\n\n    while (state.index < state.lines.length) {\n      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n      if (operation === '-' && line[0] === '+') {\n        operation = '+';\n      }\n\n      if (operation === line[0]) {\n        ret.push(line);\n        state.index++;\n      } else {\n        break;\n      }\n    }\n\n    return ret;\n  }\n\n  function collectContext(state, matchChanges) {\n    var changes = [],\n        merged = [],\n        matchIndex = 0,\n        contextChanges = false,\n        conflicted = false;\n\n    while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n      var change = state.lines[state.index],\n          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n      if (match[0] === '+') {\n        break;\n      }\n\n      contextChanges = contextChanges || change[0] !== ' ';\n      merged.push(match);\n      matchIndex++; // Consume any additions in the other block as a conflict to attempt\n      // to pull in the remaining context after this\n\n      if (change[0] === '+') {\n        conflicted = true;\n\n        while (change[0] === '+') {\n          changes.push(change);\n          change = state.lines[++state.index];\n        }\n      }\n\n      if (match.substr(1) === change.substr(1)) {\n        changes.push(change);\n        state.index++;\n      } else {\n        conflicted = true;\n      }\n    }\n\n    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n      conflicted = true;\n    }\n\n    if (conflicted) {\n      return changes;\n    }\n\n    while (matchIndex < matchChanges.length) {\n      merged.push(matchChanges[matchIndex++]);\n    }\n\n    return {\n      merged: merged,\n      changes: changes\n    };\n  }\n\n  function allRemoves(changes) {\n    return changes.reduce(function (prev, change) {\n      return prev && change[0] === '-';\n    }, true);\n  }\n\n  function skipRemoveSuperset(state, removeChanges, delta) {\n    for (var i = 0; i < delta; i++) {\n      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n      if (state.lines[state.index + i] !== ' ' + changeContent) {\n        return false;\n      }\n    }\n\n    state.index += delta;\n    return true;\n  }\n\n  function calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function (line) {\n      if (typeof line !== 'string') {\n        var myCount = calcOldNewLineCount(line.mine);\n        var theirCount = calcOldNewLineCount(line.theirs);\n\n        if (oldLines !== undefined) {\n          if (myCount.oldLines === theirCount.oldLines) {\n            oldLines += myCount.oldLines;\n          } else {\n            oldLines = undefined;\n          }\n        }\n\n        if (newLines !== undefined) {\n          if (myCount.newLines === theirCount.newLines) {\n            newLines += myCount.newLines;\n          } else {\n            newLines = undefined;\n          }\n        }\n      } else {\n        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n          newLines++;\n        }\n\n        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n          oldLines++;\n        }\n      }\n    });\n    return {\n      oldLines: oldLines,\n      newLines: newLines\n    };\n  }\n\n  // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n  function convertChangesToDMP(changes) {\n    var ret = [],\n        change,\n        operation;\n\n    for (var i = 0; i < changes.length; i++) {\n      change = changes[i];\n\n      if (change.added) {\n        operation = 1;\n      } else if (change.removed) {\n        operation = -1;\n      } else {\n        operation = 0;\n      }\n\n      ret.push([operation, change.value]);\n    }\n\n    return ret;\n  }\n\n  function convertChangesToXML(changes) {\n    var ret = [];\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (change.added) {\n        ret.push('<ins>');\n      } else if (change.removed) {\n        ret.push('<del>');\n      }\n\n      ret.push(escapeHTML(change.value));\n\n      if (change.added) {\n        ret.push('</ins>');\n      } else if (change.removed) {\n        ret.push('</del>');\n      }\n    }\n\n    return ret.join('');\n  }\n\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n    return n;\n  }\n\n  exports.Diff = Diff;\n  exports.applyPatch = applyPatch;\n  exports.applyPatches = applyPatches;\n  exports.canonicalize = canonicalize;\n  exports.convertChangesToDMP = convertChangesToDMP;\n  exports.convertChangesToXML = convertChangesToXML;\n  exports.createPatch = createPatch;\n  exports.createTwoFilesPatch = createTwoFilesPatch;\n  exports.diffArrays = diffArrays;\n  exports.diffChars = diffChars;\n  exports.diffCss = diffCss;\n  exports.diffJson = diffJson;\n  exports.diffLines = diffLines;\n  exports.diffSentences = diffSentences;\n  exports.diffTrimmedLines = diffTrimmedLines;\n  exports.diffWords = diffWords;\n  exports.diffWordsWithSpace = diffWordsWithSpace;\n  exports.merge = merge;\n  exports.parsePatch = parsePatch;\n  exports.structuredPatch = structuredPatch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}
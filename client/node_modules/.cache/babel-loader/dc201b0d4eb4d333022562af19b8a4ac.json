{"ast":null,"code":"var htmlparser2Adapter = require('parse5-htmlparser2-tree-adapter');\n/**\n * @module cheerio/static\n * @ignore\n */\n\n\nvar serialize = require('dom-serializer').default;\n\nvar defaultOptions = require('./options').default;\n\nvar flattenOptions = require('./options').flatten;\n\nvar select = require('cheerio-select-tmp').select;\n\nvar parse5 = require('parse5');\n\nvar parse = require('./parse');\n/**\n * Create a querying function, bound to a document created from the provided\n * markup. Note that similar to web browser contexts, this operation may\n * introduce `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false`\n * to switch to fragment mode and disable this.\n *\n * See the README section titled \"Loading\" for additional usage information.\n *\n * @param {string} content - Markup to be loaded.\n * @param {object} [options] - Options for the created instance.\n * @param {boolean} [isDocument] - Allows parser to be switched to fragment mode.\n *\n */\n\n\nexports.load = function (content, options, isDocument) {\n  if (content === null || content === undefined) {\n    throw new Error('cheerio.load() expects a string');\n  }\n\n  var Cheerio = require('./cheerio');\n\n  options = Object.assign({}, defaultOptions, flattenOptions(options));\n  if (isDocument === void 0) isDocument = true;\n  var root = parse(content, options, isDocument);\n\n  var initialize = function (selector, context, r, opts) {\n    if (!(this instanceof initialize)) {\n      return new initialize(selector, context, r, opts);\n    }\n\n    opts = Object.assign({}, options, opts);\n    return Cheerio.call(this, selector, context, r || root, opts);\n  }; // Ensure that selections created by the \"loaded\" `initialize` function are\n  // true Cheerio instances.\n\n\n  initialize.prototype = Object.create(Cheerio.prototype);\n  initialize.prototype.constructor = initialize; // Mimic jQuery's prototype alias for plugin authors.\n\n  initialize.fn = initialize.prototype; // Keep a reference to the top-level scope so we can chain methods that implicitly\n  // resolve selectors; e.g. $(\"<span>\").(\".bar\"), which otherwise loses ._root\n\n  initialize.prototype._originalRoot = root; // Add in the static methods\n\n  Object.assign(initialize, exports); // Add in the root\n\n  initialize._root = root; // store options\n\n  initialize._options = options;\n  return initialize;\n};\n/*\n * Helper function\n */\n\n\nfunction render(that, dom, options) {\n  if (!dom) {\n    if (that._root && that._root.children) {\n      dom = that._root.children;\n    } else {\n      return '';\n    }\n  } else if (typeof dom === 'string') {\n    dom = select(dom, that._root, options);\n  }\n\n  if (options.xmlMode || options._useHtmlParser2) {\n    return serialize(dom, options);\n  } // `dom-serializer` passes over the special \"root\" node and renders the\n  // node's children in its place. To mimic this behavior with `parse5`, an\n  // equivalent operation must be applied to the input array.\n\n\n  var nodes = 'length' in dom ? dom : [dom];\n\n  for (var index = 0; index < nodes.length; index += 1) {\n    if (nodes[index].type === 'root') {\n      nodes.splice.apply(nodes, [index, 1].concat(nodes[index].children));\n    }\n  }\n\n  return parse5.serialize({\n    children: nodes\n  }, {\n    treeAdapter: htmlparser2Adapter\n  });\n}\n/**\n * Renders the document.\n *\n * @param {string|cheerio|node} [dom] - Element to render.\n * @param {object} [options] - Options for the renderer.\n */\n\n\nexports.html = function (dom, options) {\n  // be flexible about parameters, sometimes we call html(),\n  // with options as only parameter\n  // check dom argument for dom element specific properties\n  // assume there is no 'length' or 'type' properties in the options object\n  if (Object.prototype.toString.call(dom) === '[object Object]' && !options && !('length' in dom) && !('type' in dom)) {\n    options = dom;\n    dom = undefined;\n  } // sometimes $.html() used without preloading html\n  // so fallback non existing options to the default ones\n\n\n  options = Object.assign({}, defaultOptions, this._options, flattenOptions(options || {}));\n  return render(this, dom, options);\n};\n/**\n * Render the document as XML.\n *\n * @param {string|cheerio|node} [dom] - Element to render.\n */\n\n\nexports.xml = function (dom) {\n  var options = Object.assign({}, this._options, {\n    xmlMode: true\n  });\n  return render(this, dom, options);\n};\n/**\n * Render the document as text.\n *\n * @param {string|cheerio|node} [elems] - Elements to render.\n */\n\n\nexports.text = function (elems) {\n  if (!elems) {\n    elems = this.root();\n  }\n\n  var ret = '';\n  var len = elems.length;\n  var elem;\n\n  for (var i = 0; i < len; i++) {\n    elem = elems[i];\n    if (elem.type === 'text') ret += elem.data;else if (elem.children && elem.type !== 'comment' && elem.tagName !== 'script' && elem.tagName !== 'style') {\n      ret += exports.text(elem.children);\n    }\n  }\n\n  return ret;\n};\n/**\n * Parses a string into an array of DOM nodes. The `context` argument has no\n * meaning for Cheerio, but it is maintained for API compatibility with jQuery.\n *\n * @param {string} data - Markup that will be parsed.\n * @param {any|boolean} [context] - Will be ignored. If it is a boolean it will be used as the value of `keepScripts`.\n * @param {boolean} [keepScripts] - If false all scripts will be removed.\n *\n * @alias Cheerio.parseHTML\n * @see {@link https://api.jquery.com/jQuery.parseHTML/}\n */\n\n\nexports.parseHTML = function (data, context, keepScripts) {\n  var parsed;\n\n  if (!data || typeof data !== 'string') {\n    return null;\n  }\n\n  if (typeof context === 'boolean') {\n    keepScripts = context;\n  }\n\n  parsed = this.load(data, defaultOptions, false);\n\n  if (!keepScripts) {\n    parsed('script').remove();\n  } // The `children` array is used by Cheerio internally to group elements that\n  // share the same parents. When nodes created through `parseHTML` are\n  // inserted into previously-existing DOM structures, they will be removed\n  // from the `children` array. The results of `parseHTML` should remain\n  // constant across these operations, so a shallow copy should be returned.\n\n\n  return parsed.root()[0].children.slice();\n};\n/**\n * Sometimes you need to work with the top-level root element. To query it, you\n * can use `$.root()`.\n *\n * @alias Cheerio.root\n *\n * @example\n * $.root().append('<ul id=\"vegetables\"></ul>').html();\n * //=> <ul id=\"fruits\">...</ul><ul id=\"vegetables\"></ul>\n */\n\n\nexports.root = function () {\n  return this(this._root);\n};\n/**\n * Checks to see if the `contained` DOM element is a descendant of the\n * `container` DOM element.\n *\n * @param {node} container - Potential parent node.\n * @param {node} contained - Potential child node.\n * @returns {boolean}\n *\n * @alias Cheerio.contains\n * @see {@link https://api.jquery.com/jQuery.contains}\n */\n\n\nexports.contains = function (container, contained) {\n  // According to the jQuery API, an element does not \"contain\" itself\n  if (contained === container) {\n    return false;\n  } // Step up the descendants, stopping when the root element is reached\n  // (signaled by `.parent` returning a reference to the same object)\n\n\n  while (contained && contained !== contained.parent) {\n    contained = contained.parent;\n\n    if (contained === container) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * $.merge().\n *\n * @param {Array|cheerio} arr1 - First array.\n * @param {Array|cheerio} arr2 - Second array.\n *\n * @alias Cheerio.merge\n * @see {@link https://api.jquery.com/jQuery.merge}\n */\n\n\nexports.merge = function (arr1, arr2) {\n  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {\n    return;\n  }\n\n  var newLength = arr1.length + arr2.length;\n\n  for (var i = 0; i < arr2.length; i++) {\n    arr1[i + arr1.length] = arr2[i];\n  }\n\n  arr1.length = newLength;\n  return arr1;\n};\n\nfunction isArrayLike(item) {\n  if (Array.isArray(item)) {\n    return true;\n  }\n\n  if (typeof item !== 'object' || !Object.prototype.hasOwnProperty.call(item, 'length') || typeof item.length !== 'number' || item.length < 0) {\n    return false;\n  }\n\n  for (var i = 0; i < item.length; i++) {\n    if (!(i in item)) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/conrad/Documents/tarot/tarot-cards/node_modules/cheerio/lib/static.js"],"names":["htmlparser2Adapter","require","serialize","default","defaultOptions","flattenOptions","flatten","select","parse5","parse","exports","load","content","options","isDocument","undefined","Error","Cheerio","Object","assign","root","initialize","selector","context","r","opts","call","prototype","create","constructor","fn","_originalRoot","_root","_options","render","that","dom","children","xmlMode","_useHtmlParser2","nodes","index","length","type","splice","apply","concat","treeAdapter","html","toString","xml","text","elems","ret","len","elem","i","data","tagName","parseHTML","keepScripts","parsed","remove","slice","contains","container","contained","parent","merge","arr1","arr2","isArrayLike","newLength","item","Array","isArray","hasOwnProperty"],"mappings":"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","sourcesContent":["var htmlparser2Adapter = require('parse5-htmlparser2-tree-adapter');\n\n/**\n * @module cheerio/static\n * @ignore\n */\n\nvar serialize = require('dom-serializer').default;\nvar defaultOptions = require('./options').default;\nvar flattenOptions = require('./options').flatten;\nvar select = require('cheerio-select-tmp').select;\nvar parse5 = require('parse5');\nvar parse = require('./parse');\n\n/**\n * Create a querying function, bound to a document created from the provided\n * markup. Note that similar to web browser contexts, this operation may\n * introduce `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false`\n * to switch to fragment mode and disable this.\n *\n * See the README section titled \"Loading\" for additional usage information.\n *\n * @param {string} content - Markup to be loaded.\n * @param {object} [options] - Options for the created instance.\n * @param {boolean} [isDocument] - Allows parser to be switched to fragment mode.\n *\n */\nexports.load = function (content, options, isDocument) {\n  if (content === null || content === undefined) {\n    throw new Error('cheerio.load() expects a string');\n  }\n\n  var Cheerio = require('./cheerio');\n\n  options = Object.assign({}, defaultOptions, flattenOptions(options));\n\n  if (isDocument === void 0) isDocument = true;\n\n  var root = parse(content, options, isDocument);\n\n  var initialize = function (selector, context, r, opts) {\n    if (!(this instanceof initialize)) {\n      return new initialize(selector, context, r, opts);\n    }\n    opts = Object.assign({}, options, opts);\n    return Cheerio.call(this, selector, context, r || root, opts);\n  };\n\n  // Ensure that selections created by the \"loaded\" `initialize` function are\n  // true Cheerio instances.\n  initialize.prototype = Object.create(Cheerio.prototype);\n  initialize.prototype.constructor = initialize;\n\n  // Mimic jQuery's prototype alias for plugin authors.\n  initialize.fn = initialize.prototype;\n\n  // Keep a reference to the top-level scope so we can chain methods that implicitly\n  // resolve selectors; e.g. $(\"<span>\").(\".bar\"), which otherwise loses ._root\n  initialize.prototype._originalRoot = root;\n\n  // Add in the static methods\n  Object.assign(initialize, exports);\n\n  // Add in the root\n  initialize._root = root;\n  // store options\n  initialize._options = options;\n\n  return initialize;\n};\n\n/*\n * Helper function\n */\n\nfunction render(that, dom, options) {\n  if (!dom) {\n    if (that._root && that._root.children) {\n      dom = that._root.children;\n    } else {\n      return '';\n    }\n  } else if (typeof dom === 'string') {\n    dom = select(dom, that._root, options);\n  }\n\n  if (options.xmlMode || options._useHtmlParser2) {\n    return serialize(dom, options);\n  }\n\n  // `dom-serializer` passes over the special \"root\" node and renders the\n  // node's children in its place. To mimic this behavior with `parse5`, an\n  // equivalent operation must be applied to the input array.\n  var nodes = 'length' in dom ? dom : [dom];\n  for (var index = 0; index < nodes.length; index += 1) {\n    if (nodes[index].type === 'root') {\n      nodes.splice.apply(nodes, [index, 1].concat(nodes[index].children));\n    }\n  }\n\n  return parse5.serialize(\n    { children: nodes },\n    { treeAdapter: htmlparser2Adapter }\n  );\n}\n\n/**\n * Renders the document.\n *\n * @param {string|cheerio|node} [dom] - Element to render.\n * @param {object} [options] - Options for the renderer.\n */\nexports.html = function (dom, options) {\n  // be flexible about parameters, sometimes we call html(),\n  // with options as only parameter\n  // check dom argument for dom element specific properties\n  // assume there is no 'length' or 'type' properties in the options object\n  if (\n    Object.prototype.toString.call(dom) === '[object Object]' &&\n    !options &&\n    !('length' in dom) &&\n    !('type' in dom)\n  ) {\n    options = dom;\n    dom = undefined;\n  }\n\n  // sometimes $.html() used without preloading html\n  // so fallback non existing options to the default ones\n  options = Object.assign(\n    {},\n    defaultOptions,\n    this._options,\n    flattenOptions(options || {})\n  );\n\n  return render(this, dom, options);\n};\n\n/**\n * Render the document as XML.\n *\n * @param {string|cheerio|node} [dom] - Element to render.\n */\nexports.xml = function (dom) {\n  var options = Object.assign({}, this._options, { xmlMode: true });\n\n  return render(this, dom, options);\n};\n\n/**\n * Render the document as text.\n *\n * @param {string|cheerio|node} [elems] - Elements to render.\n */\nexports.text = function (elems) {\n  if (!elems) {\n    elems = this.root();\n  }\n\n  var ret = '';\n  var len = elems.length;\n  var elem;\n\n  for (var i = 0; i < len; i++) {\n    elem = elems[i];\n    if (elem.type === 'text') ret += elem.data;\n    else if (\n      elem.children &&\n      elem.type !== 'comment' &&\n      elem.tagName !== 'script' &&\n      elem.tagName !== 'style'\n    ) {\n      ret += exports.text(elem.children);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Parses a string into an array of DOM nodes. The `context` argument has no\n * meaning for Cheerio, but it is maintained for API compatibility with jQuery.\n *\n * @param {string} data - Markup that will be parsed.\n * @param {any|boolean} [context] - Will be ignored. If it is a boolean it will be used as the value of `keepScripts`.\n * @param {boolean} [keepScripts] - If false all scripts will be removed.\n *\n * @alias Cheerio.parseHTML\n * @see {@link https://api.jquery.com/jQuery.parseHTML/}\n */\nexports.parseHTML = function (data, context, keepScripts) {\n  var parsed;\n\n  if (!data || typeof data !== 'string') {\n    return null;\n  }\n\n  if (typeof context === 'boolean') {\n    keepScripts = context;\n  }\n\n  parsed = this.load(data, defaultOptions, false);\n  if (!keepScripts) {\n    parsed('script').remove();\n  }\n\n  // The `children` array is used by Cheerio internally to group elements that\n  // share the same parents. When nodes created through `parseHTML` are\n  // inserted into previously-existing DOM structures, they will be removed\n  // from the `children` array. The results of `parseHTML` should remain\n  // constant across these operations, so a shallow copy should be returned.\n  return parsed.root()[0].children.slice();\n};\n\n/**\n * Sometimes you need to work with the top-level root element. To query it, you\n * can use `$.root()`.\n *\n * @alias Cheerio.root\n *\n * @example\n * $.root().append('<ul id=\"vegetables\"></ul>').html();\n * //=> <ul id=\"fruits\">...</ul><ul id=\"vegetables\"></ul>\n */\nexports.root = function () {\n  return this(this._root);\n};\n\n/**\n * Checks to see if the `contained` DOM element is a descendant of the\n * `container` DOM element.\n *\n * @param {node} container - Potential parent node.\n * @param {node} contained - Potential child node.\n * @returns {boolean}\n *\n * @alias Cheerio.contains\n * @see {@link https://api.jquery.com/jQuery.contains}\n */\nexports.contains = function (container, contained) {\n  // According to the jQuery API, an element does not \"contain\" itself\n  if (contained === container) {\n    return false;\n  }\n\n  // Step up the descendants, stopping when the root element is reached\n  // (signaled by `.parent` returning a reference to the same object)\n  while (contained && contained !== contained.parent) {\n    contained = contained.parent;\n    if (contained === container) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * $.merge().\n *\n * @param {Array|cheerio} arr1 - First array.\n * @param {Array|cheerio} arr2 - Second array.\n *\n * @alias Cheerio.merge\n * @see {@link https://api.jquery.com/jQuery.merge}\n */\nexports.merge = function (arr1, arr2) {\n  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {\n    return;\n  }\n  var newLength = arr1.length + arr2.length;\n  for (var i = 0; i < arr2.length; i++) {\n    arr1[i + arr1.length] = arr2[i];\n  }\n  arr1.length = newLength;\n  return arr1;\n};\n\nfunction isArrayLike(item) {\n  if (Array.isArray(item)) {\n    return true;\n  }\n\n  if (\n    typeof item !== 'object' ||\n    !Object.prototype.hasOwnProperty.call(item, 'length') ||\n    typeof item.length !== 'number' ||\n    item.length < 0\n  ) {\n    return false;\n  }\n\n  for (var i = 0; i < item.length; i++) {\n    if (!(i in item)) {\n      return false;\n    }\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"script"}
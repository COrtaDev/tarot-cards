{"ast":null,"code":"\"use strict\";\n\nfunction _interopDefault(e) {\n  return e && \"object\" == typeof e && \"default\" in e ? e.default : e;\n}\n\nfunction trimWrappers(e) {\n  return e.replace(/\\[\\[/g, \"\").replace(/\\]\\]/g, \"\").replace(/\\{\\{/g, \"\").replace(/\\}\\}/g, \"\").trim();\n}\n\nfunction trimOr(e) {\n  var t = e.indexOf(\"|\");\n  return -1 !== t ? e.substring(0, t) : e;\n}\n\nfunction getValue(e, t) {\n  if (!e) return null;\n  var r = e.trim().replace(/File:/, \"\").replace(/\\{\\{\\d+\\}\\}/g, \"\").replace(extraPropertyPattern, \"\").replace(endingPattern, \"\");\n  if (\"y\" === r || \"yes\" === r) return !0;\n  if (\"birthPlace\" == t) return e.trim();\n  var a = r.match(linksPattern);\n  return a ? a[0].split(linkSeparatorPattern).filter(function (e) {\n    return e;\n  }) : trimOr(trimWrappers(r));\n}\n\nfunction dataType(e) {\n  var t = e.globalPattern,\n      r = e.parsePattern,\n      a = e.parse,\n      n = e.variable,\n      l = e.name;\n  return function (e) {\n    var i = e.match(t);\n\n    if (!i) {\n      var s;\n      return s = {}, defineProperty(s, l, []), defineProperty(s, \"sourceAfter\", e), s;\n    }\n\n    var o = i.map(function (e) {\n      return a(e.match(r));\n    }),\n        u = i.reduce(function (e, t, r) {\n      return o[r] === DO_NOT_REPLACE ? e : e.replace(t, \"$\" + n + \"_\" + r);\n    }, e);\n    return {\n      data: defineProperty({}, l, o),\n      sourceAfter: u\n    };\n  };\n}\n\nfunction byDataHandler(e, t) {\n  var r = e.source,\n      a = e.context,\n      n = t(r),\n      l = n.data,\n      i = n.sourceAfter;\n  return {\n    context: Object.assign({}, a, l),\n    source: i\n  };\n}\n\nfunction extractData(e) {\n  return dataTypes$1.map(function (e) {\n    return e.handler;\n  }).reduce(byDataHandler, {\n    context: {},\n    source: e\n  });\n}\n\nfunction findPropertyList(e) {\n  var t = e.match(keyValueGlobalPattern);\n  return t ? t.map(function (e) {\n    var t = keyValuePattern.exec(e);\n    if (!t) return null;\n    var r = slicedToArray(t, 3),\n        a = r[1],\n        n = r[2],\n        l = camelCase(a.trim());\n    return {\n      key: l,\n      value: getValue(n, l)\n    };\n  }).filter(function (e) {\n    return e;\n  }) : [];\n}\n\nfunction fillVariables(e, t, r) {\n  var a = r.simplifyDataValues;\n  if (\"string\" != typeof e) return console.log(\"Warning: Something went wrong. Could not fill variables in: (\" + (void 0 === e ? \"undefined\" : _typeof(e)) + \") \" + JSON.stringify(e)), {};\n  var n = dataTypes$1.find(function (t) {\n    return e.match(t.pattern);\n  });\n\n  if (n) {\n    var l = n.pattern.exec(e),\n        i = slicedToArray(l, 2),\n        s = i[0],\n        o = i[1],\n        u = t[n.name][parseInt(o, 10)];\n    return a || \"string\" != typeof u ? u : e.replace(s, u);\n  }\n\n  return e;\n}\n\nfunction fillVariablesUntilDone(e, t, r) {\n  if (void 0 === e) return e;\n  if (e instanceof Date) return e;\n  if (\"number\" == typeof e) return e;\n  if (Array.isArray(e)) return e.map(function (e) {\n    return fillVariablesUntilDone(e, t, r);\n  });\n  if (\"object\" === (void 0 === e ? \"undefined\" : _typeof(e))) return Object.keys(e).reduce(function (a, n) {\n    return Object.assign(a, defineProperty({}, n, fillVariablesUntilDone(e[n], t, r)));\n  }, {});\n  var a = fillVariables(e, t, r);\n  return a === e ? e : fillVariablesUntilDone(a, t, r);\n}\n\nfunction handleSmallData(e, t, r) {\n  var a = r.simplifyDataValues;\n\n  if (\"string\" == typeof e && e.match(smallDataType.pattern)) {\n    var n = e.replace(smallDataType.pattern, \"\").replace(/,/, \"\").trim(),\n        l = smallDataType.pattern.exec(e),\n        i = slicedToArray(l, 2),\n        s = i[1],\n        o = t[smallDataType.name][parseInt(s, 10)],\n        u = {\n      primary: getVariableValue(n, t, {\n        simplifyDataValues: a\n      }),\n      secondary: getVariableValue(o, t, {\n        simplifyDataValues: a\n      })\n    };\n    return a ? u.primary : u;\n  }\n\n  return null;\n}\n\nfunction getVariableValue(e, t) {\n  var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n      a = r.simplifyDataValues,\n      n = void 0 === a || a,\n      l = handleSmallData(e, t, {\n    simplifyDataValues: n\n  });\n  return l || fillVariablesUntilDone(e, t, {\n    simplifyDataValues: n\n  });\n}\n\nfunction reduceVariable(e, t, r, a) {\n  if (null === t) return null;\n  if (\"boolean\" == typeof t) return t;\n  if (Array.isArray(t)) return t.map(function (e) {\n    return getVariableValue(e, r, a);\n  });\n\n  if (e.match(/areaTotal/) || e.match(/population/)) {\n    var n = numberParse(t);\n    if (!1 === n && (n = parseFloat(t, 10)), !isNaN(n)) return n;\n  }\n\n  if (e.match(/date/i)) {\n    var l = +new Date(t);\n    if (!isNaN(l)) return new Date(t);\n  }\n\n  var i = getVariableValue(t, r, a);\n  return Array.isArray(i) ? i.map(function (e) {\n    return getVariableValue(e, r, a);\n  }) : i;\n}\n\nfunction byVariableReduction(e, t) {\n  return function (r, a) {\n    var n = a.key,\n        l = a.value,\n        i = reduceVariable(n, l, e, t);\n    return \"\" === i || null === i ? r : Object.assign({}, r, defineProperty({}, n, i));\n  };\n}\n\nfunction extractProperties(e, t) {\n  var r = e.source,\n      a = e.context;\n  return findPropertyList(r).reduce(byVariableReduction(a, t), {});\n}\n\nfunction transformProperties(e) {\n  return Object.keys(e).reduce(function (t, r) {\n    var a = e[r],\n        n = r.match(blankNamePattern);\n\n    if (n) {\n      var l = n[1] || \"\",\n          i = e[\"blank\" + l + \"NameSec2\"],\n          s = e[\"blank\" + l + \"InfoSec2\"];\n      return \"string\" != typeof i ? t : Object.assign(t, defineProperty({}, camelCase(i), s));\n    }\n\n    return r.match(blankInfoPattern) ? t : Object.assign(t, defineProperty({}, r, a));\n  }, {});\n}\n\nfunction findOuterIndex(e) {\n  for (var t = [], r = 0; r < e.length - 1; r++) {\n    var a = e.substr(r, 2);\n\n    if (\"{{\" !== a) {\n      if (\"}}\" === a) {\n        t.pop();\n        if (0 === t.length) return r + 2;\n        r++;\n      }\n    } else t.push(r), r++;\n  }\n}\n\nfunction parse(e) {\n  var t = e.match(infoBoxStartPattern);\n  if (!t) return {\n    data: e,\n    sourceLeft: null\n  };\n  var r = t.index,\n      a = e.substring(r),\n      n = findOuterIndex(a);\n  if (!n) return {\n    data: e,\n    sourceLeft: null\n  };\n  var l = a.substring(0, n),\n      i = e.substring(n);\n  return {\n    data: l,\n    sourceLeft: !i.match(infoBoxStartPattern) ? null : i\n  };\n}\n\nfunction extractInfoboxes(e) {\n  for (var t = parse(e), r = [t.data]; t.sourceLeft;) t = parse(t.sourceLeft), r.push(t.data);\n\n  return r;\n}\n\nfunction cleanSource(e) {\n  return e.replace(/''/g, \"\").replace(/\\|display=inline/g, \"\").replace(/<br\\s?\\/?>/g, \",\").replace(/<ref(\\s\\w+=[^>]+)?>.*<\\/ref>/g, \"\").replace(/&minus;/g, \"-\").replace(/<sup>/g, \"^\").replace(/\\{\\{sfn\\|([^\\}\\}]+)\\}\\}/g, \"\").replace(/\\{\\{efn\\|([^\\}\\}]+)\\}\\}/g, \"\").replace(/âˆ’/g, \"-\").replace(/<\\/sup>/g, \"\").replace(/<ref(\\s\\w+=[^>]+)?\\s?\\/>/g, \"\").replace(/<!--([\\s\\S]*?)-->/g, \"\").replace(/&nbsp;/g, \" \").replace(\"|''See list''\", \"\");\n}\n\nfunction transformRowSpan(e) {\n  return e.map(transformCells).reduce(function (e, t, r) {\n    for (var a = 0 === r ? 0 : 1, n = 0; n < t.length; n++) e[n + a] || (e[n + a] = {}), t[n] && (e[n + a][t[n]] = 1);\n\n    return e;\n  }, []).map(function (e) {\n    return Object.keys(e).join(\",\");\n  }).join(\" || \");\n}\n\nfunction getMatches(e, t) {\n  for (var r = void 0, a = []; null !== (r = t.exec(e));) a.push({\n    value: r[1] && r[1].trim(),\n    start: r.index,\n    end: r.index + r[0].length\n  });\n\n  return a;\n}\n\nfunction parseTableData(e) {\n  var t = e.match(rowPattern$1);\n  return t ? t.map(function (e) {\n    var t = e.match(rowPatternSingle);\n    return slicedToArray(t, 2)[1].trim().split(\"|\").slice(1);\n  }) : [];\n}\n\nfunction getTables(e) {\n  var t = getMatches(e, tableStartPattern$1),\n      r = getMatches(e, tableEndPattern$1);\n  return t.map(function (t, a) {\n    var n = r[a];\n    if (!n) throw new Error(\"[Table Parsing] Failed to pair table\");\n    return {\n      rows: parseTableData(e.substring(t.end, n.start).trim().replace(/'''/g, \"\")),\n      start: t.start,\n      end: n.end\n    };\n  });\n}\n\nfunction last(e) {\n  return e.length ? e[e.length - 1] : void 0;\n}\n\nvar camelCase = _interopDefault(require(\"camelcase\")),\n    _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n  return typeof e;\n} : function (e) {\n  return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n},\n    defineProperty = function (e, t, r) {\n  return t in e ? Object.defineProperty(e, t, {\n    value: r,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = r, e;\n},\n    slicedToArray = function () {\n  function e(e, t) {\n    var r = [],\n        a = !0,\n        n = !1,\n        l = void 0;\n\n    try {\n      for (var i, s = e[Symbol.iterator](); !(a = (i = s.next()).done) && (r.push(i.value), !t || r.length !== t); a = !0);\n    } catch (e) {\n      n = !0, l = e;\n    } finally {\n      try {\n        !a && s.return && s.return();\n      } finally {\n        if (n) throw l;\n      }\n    }\n\n    return r;\n  }\n\n  return function (t, r) {\n    if (Array.isArray(t)) return t;\n    if (Symbol.iterator in Object(t)) return e(t, r);\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  };\n}(),\n    toConsumableArray = function (e) {\n  if (Array.isArray(e)) {\n    for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];\n\n    return r;\n  }\n\n  return Array.from(e);\n},\n    smallGlobalPattern = /\\{\\{small\\|([^\\}\\}]+)\\}\\}/g,\n    smallPattern = /small\\|([^\\}\\}]+)\\}\\}/,\n    small = {\n  globalPattern: smallGlobalPattern,\n  parsePattern: smallPattern,\n  parse: function (e) {\n    return slicedToArray(e, 2)[1];\n  },\n  variable: \"SMALL\",\n  name: \"smalls\"\n},\n    flagGlobalPattern = /\\{\\{flag\\|([^\\}\\}]+)\\}\\}/g,\n    flagPattern = /flag\\|([^\\}\\}]+)\\}\\}/,\n    flag = {\n  globalPattern: flagGlobalPattern,\n  parsePattern: flagPattern,\n  parse: function (e) {\n    return slicedToArray(e, 2)[1];\n  },\n  variable: \"FLAG\",\n  name: \"flags\"\n},\n    coordsGlobalPattern = /\\{\\{coord\\|([^\\}\\}]+)\\}\\}/g,\n    coordsPattern = /coord\\|([^\\}\\}]+)\\}\\}/,\n    coords = {\n  globalPattern: coordsGlobalPattern,\n  parsePattern: coordsPattern,\n  parse: function (e) {\n    return slicedToArray(e, 2)[1];\n  },\n  variable: \"COORD\",\n  name: \"coords\"\n},\n    globalPattern = /\\[\\[([^\\]\\|]+)\\|?([^\\]]+)?\\]\\]/g,\n    pattern = /\\[\\[([^\\]\\|]+)\\|?([^\\]]+)?\\]\\]/,\n    instances = {\n  globalPattern: globalPattern,\n  parsePattern: pattern,\n  parse: function (e) {\n    var t = slicedToArray(e, 3),\n        r = t[1],\n        a = t[2];\n    return r || a;\n  },\n  variable: \"INSTANCE\",\n  name: \"instances\"\n},\n    extraPropertyPattern = /\\n?\\s?\\|\\s?\\w+$/,\n    endingPattern = /\\n\\}\\}$/,\n    linksPattern = /((\\$\\w+_\\d+)\\s*,?\\s*){2,}/g,\n    linkSeparatorPattern = /[,\\s?]/g,\n    listItemPrefixPattern = /^\\|\\s?/,\n    unbulletedListGlobalPattern = /\\{\\{(?:unbulleted list|ubl|ubt|ublist|unbullet)\\s?\\|([^\\}\\}]+)\\}\\}/g,\n    unbulletedListItemPattern = /\\|\\s*([^|}]+)/g,\n    unbulletedLists = {\n  globalPattern: unbulletedListGlobalPattern,\n  parsePattern: unbulletedListItemPattern,\n  parse: function (e) {\n    return e ? e.map(function (e) {\n      return e.replace(listItemPrefixPattern, \"\").trim();\n    }).filter(function (e) {\n      return e && e.length;\n    }) : [];\n  },\n  variable: \"UNBULLETED_LIST\",\n  name: \"unbulletedLists\"\n},\n    listItemPrefixPattern$1 = /^\\*\\s*/,\n    plainListGlobalPattern = /\\n(\\*\\s*[^*|]+)+/g,\n    plainListItemPattern = /\\*\\s*([^*|]+)/g,\n    unmarkedLists = {\n  globalPattern: plainListGlobalPattern,\n  parsePattern: plainListItemPattern,\n  parse: function (e) {\n    return e ? e.map(function (e) {\n      return e.replace(listItemPrefixPattern$1, \"\").trim();\n    }).filter(function (e) {\n      return e && e.length;\n    }) : [];\n  },\n  variable: \"UNMARKED_LIST\",\n  name: \"unmarkedLists\"\n},\n    listItemPrefixPattern$2 = /^\\*\\s?/,\n    plainListGlobalPattern$1 = /\\{\\{f?p?P?l?a?i?n?t?list\\s?\\|([^\\}\\}]+)\\}\\}/g,\n    plainListItemPattern$1 = /\\*\\s*([^*}]+)/g,\n    plainLists = {\n  globalPattern: plainListGlobalPattern$1,\n  parsePattern: plainListItemPattern$1,\n  parse: function (e) {\n    return e ? e.map(function (e) {\n      return e.replace(listItemPrefixPattern$2, \"\").trim();\n    }).filter(function (e) {\n      return e && e.length;\n    }) : [];\n  },\n  variable: \"PLAIN_LIST\",\n  name: \"plainLists\"\n},\n    marriageGlobalPattern = /\\{\\{Marriage\\|([^\\}\\}]+)\\}\\}/g,\n    marriagePattern = /Marriage\\|([^|]+)\\|(.*)\\}\\}/,\n    marriages = {\n  globalPattern: marriageGlobalPattern,\n  parsePattern: marriagePattern,\n  parse: function (e) {\n    var t = slicedToArray(e, 3);\n    return {\n      who: t[1],\n      married: t[2]\n    };\n  },\n  variable: \"MARRIAGE\",\n  name: \"marriages\"\n},\n    otherGlobalPattern = /\\{\\{([^|\\n]+)\\|([^|\\n]+)\\|?([^\\}\\n]+)?\\}\\}/g,\n    otherPattern = /\\{\\{([^|\\n]+)\\|([^|\\n]+)\\|?([^\\}\\n]+)?\\}\\}/,\n    other = {\n  globalPattern: otherGlobalPattern,\n  parsePattern: otherPattern,\n  parse: function (e) {\n    var t = slicedToArray(e, 4),\n        r = t[1];\n    t[2], t[3];\n    return r;\n  },\n  variable: \"OTHER\",\n  name: \"others\"\n},\n    birthDateGlobalPattern = /\\{\\{birth\\sdate([^\\}\\}]+)\\}\\}/gi,\n    birthDatePattern = /(\\d+)\\|(\\d+)\\|(\\d+)/,\n    millisInYear = 31536e6,\n    birthDates = {\n  globalPattern: birthDateGlobalPattern,\n  parsePattern: birthDatePattern,\n  parse: function (e) {\n    var t = slicedToArray(e, 4),\n        r = t[1],\n        a = t[2],\n        n = t[3],\n        l = new Date(r, a - 1, n);\n    return {\n      date: l,\n      age: Math.floor((Date.now() - +l) / millisInYear)\n    };\n  },\n  variable: \"BIRTH_DATE\",\n  name: \"birthDates\"\n},\n    DO_NOT_REPLACE = Symbol(\"DO NOT REPLACE\"),\n    labeledDateGlobalPattern = /\\{\\{([^\\n\\}\\}]+)\\}\\}/g,\n    labeledDatePattern = /(.*)/,\n    labeledDates = {\n  globalPattern: labeledDateGlobalPattern,\n  parsePattern: labeledDatePattern,\n  parse: function (e) {\n    var t = e[0].indexOf(\"|\");\n\n    if (t > -1) {\n      var r = e[0].substring(t + 1).slice(0, -2),\n          a = new Date(r + \" GMT\");\n      if (!isNaN(a.getTime())) return {\n        date: a\n      };\n      if (a = new Date(r.split(\"|\").join(\"-\") + \" GMT\"), !isNaN(a.getTime())) return {\n        date: a\n      };\n    }\n\n    return DO_NOT_REPLACE;\n  },\n  variable: \"LABELED_DATE\",\n  name: \"labeledDates\"\n},\n    deathDateGlobalPattern = /\\{\\{death\\sdate\\sand\\sage([^\\}\\}]+)\\}\\}/gi,\n    deathDatePattern = /(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|?(\\d+)?\\|?(\\d+)?/,\n    millisInYear$1 = 31536e6,\n    deathDates = {\n  globalPattern: deathDateGlobalPattern,\n  parsePattern: deathDatePattern,\n  parse: function (e) {\n    var t = slicedToArray(e, 7),\n        r = t[1],\n        a = t[2],\n        n = t[3],\n        l = t[4],\n        i = t[5],\n        s = void 0 === i ? 0 : i,\n        o = t[6],\n        u = void 0 === o ? 0 : o,\n        c = new Date(r, a - 1, n),\n        f = new Date(l, s - 1, u);\n    return {\n      date: c,\n      age: Math.floor((Number(c) - Number(f)) / millisInYear$1)\n    };\n  },\n  variable: \"DEATH_DATE\",\n  name: \"deathDates\"\n},\n    URLGlobalPattern = /\\{\\{URL\\|([^\\}\\}]+)\\}\\}/g,\n    URLPattern = /URL\\|([^\\}\\}]+)\\}\\}/,\n    url = {\n  globalPattern: URLGlobalPattern,\n  parsePattern: URLPattern,\n  parse: function (e) {\n    return slicedToArray(e, 2)[1];\n  },\n  variable: \"URL\",\n  name: \"urls\"\n},\n    websiteGlobalPattern = /\\[(https?):\\/\\/((?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6})\\b([-a-zA-Z0-9@:%_\\+.~#?&\\/\\/=]*)\\s+([\\w\\s]+)\\]/g,\n    websitePattern = /\\[(https?):\\/\\/((?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6})\\b([-a-zA-Z0-9@:%_\\+.~#?&\\/\\/=]*)\\s+([\\w\\s]+)\\]/,\n    website = {\n  globalPattern: websiteGlobalPattern,\n  parsePattern: websitePattern,\n  parse: function (e) {\n    var t = slicedToArray(e, 5),\n        r = t[1],\n        a = t[2],\n        n = t[3];\n    return {\n      protocol: r,\n      hostname: a,\n      path: n,\n      title: t[4],\n      url: r + \"://\" + a + n\n    };\n  },\n  variable: \"WEBSITE\",\n  name: \"websites\"\n},\n    convertGlobalPattern = /\\{\\{convert\\|([\\d\\.]+)\\|(\\w+)/g,\n    convertPattern = /\\{\\{convert\\|([\\d\\.]+)\\|(\\w+)/,\n    convert = {\n  globalPattern: convertGlobalPattern,\n  parsePattern: convertPattern,\n  parse: function (e) {\n    var t = slicedToArray(e, 3);\n    return t[1] + \" \" + t[2];\n  },\n  variable: \"CONVERT\",\n  name: \"converts\"\n},\n    dataTypes = [instances, small, flag, coords, marriages, birthDates, labeledDates, deathDates, unbulletedLists, website, url, convert, other, plainLists, unmarkedLists],\n    dataTypes$1 = dataTypes.map(function (e) {\n  return {\n    handler: dataType(e),\n    name: e.name,\n    pattern: new RegExp(\"\\\\$\" + e.variable + \"_(\\\\d+)\")\n  };\n}),\n    keyValueGlobalPattern = /\\|\\s*([-'\\u0400-\\u04FF\\w\\s]+)\\s*=\\s*([^|]+)?/g,\n    keyValuePattern = /\\|\\s*([-'\\u0400-\\u04FF\\w\\s]+)\\s*=\\s*([^|]+)?/,\n    numberParse = function (e) {\n  return \"string\" == typeof e && (e = e.trim().replace(/ /g, \"\"), e.match(/,/) && e.match(/\\./) ? e.indexOf(\",\") < e.indexOf(\".\") ? parseEnglish(e) : parseSpanish(e) : e.match(/,/) && !e.match(/\\./) ? e.match(/,/g).length > 1 ? parseEnglish(e) : e.match(/,[0-9]{3}($|^[0-9])/) ? parseEnglish(e) : parseSpanish(e) : !e.match(/,/) && e.match(/\\./) ? e.match(/\\./g).length > 1 ? parseSpanish(e) : e.match(/\\.[0-9]{3}($|^[0-9])/) ? parseSpanish(e) : parseEnglish(e) : (+e).toString() === e && +e);\n},\n    parseEnglish = function (e) {\n  return +e.replace(/,/g, \"\");\n},\n    parseSpanish = function (e) {\n  return +e.replace(/\\./g, \"\").replace(/,/g, \".\");\n},\n    smallDataType = dataTypes$1.find(function (e) {\n  return \"smalls\" === e.name;\n}),\n    blankNamePattern = /blank(\\d+)?NameSec2/,\n    blankInfoPattern = /blank(\\d+)?InfoSec2/,\n    infoBoxStartPattern = /{{\\w*box/,\n    tableStartPattern = /{\\|(.*)\\n?/,\n    tableEndPattern = /\\n\\|}/,\n    headersPattern = /!\\s?(.*)/g,\n    rowPattern = /\\|-/,\n    cellSeparatorPattern = /(?:\\n\\|)|(?:\\|\\|)/,\n    linkPattern = /\\[\\[([^\\]]+)\\]\\]/g,\n    linkNamePattern = /^.*\\|/,\n    inlineHeaderPattern = \"!!\",\n    actionPattern = /{{anchor\\|(.*)}}/g,\n    ticks = /'''/g,\n    rowSpanCountPattern = /rowspan=\"(\\d+)\"/,\n    stripLinks = function (e) {\n  return e.replace(linkPattern, function (e, t) {\n    return t.replace(linkNamePattern, \"\").trim() || t;\n  });\n},\n    removeActions = function (e) {\n  return e.replace(actionPattern, \"\");\n},\n    transformCell = function (e) {\n  return stripLinks(removeActions(e || \"\")).replace(rowSpanCountPattern, \"\").replace(linkNamePattern, \"\").replace(ticks, \"\").trim();\n},\n    transformCells = function (e) {\n  return e.split(cellSeparatorPattern).map(transformCell);\n},\n    findIndex = function (e, t) {\n  var r = e.match(t);\n  return r ? r.index : -1;\n},\n    findTableStart = function (e) {\n  var t = e.match(tableStartPattern);\n  return t ? t.index + t[0].length : -1;\n},\n    findTableEnd = function (e) {\n  return findIndex(e, tableEndPattern);\n},\n    getHeaders = function (e) {\n  for (var t = [], r = void 0; r = headersPattern.exec(e);) t.push.apply(t, toConsumableArray(r[1].split(inlineHeaderPattern).map(transformCell)));\n\n  return t;\n},\n    getRows = function (e) {\n  var t = e.split(rowPattern).map(function (e) {\n    return e.replace(/^.*\\n+?\\|/, \"\").trim();\n  }).filter(function (e) {\n    return e;\n  }),\n      r = [],\n      a = 0,\n      n = 0,\n      l = [],\n      i = !0,\n      s = !1,\n      o = void 0;\n\n  try {\n    for (var u, c = t[Symbol.iterator](); !(i = (u = c.next()).done); i = !0) {\n      var f = u.value,\n          p = f.match(rowSpanCountPattern);\n      p && (a = 0, n = parseInt(p[1]), l = []), a < n ? (l.push(f), ++a === n && r.push(transformRowSpan(l))) : r.push(f);\n    }\n  } catch (e) {\n    s = !0, o = e;\n  } finally {\n    try {\n      !i && c.return && c.return();\n    } finally {\n      if (s) throw o;\n    }\n  }\n\n  return r;\n},\n    getNextTable = function (e) {\n  var t = e,\n      r = findTableStart(t);\n  if (-1 === r) return null;\n  t = t.substring(r);\n  var a = findTableEnd(t);\n  if (-1 === a) return null;\n  t = t.substring(0, a);\n  var n = getRows(t);\n  if (!n.length) return null;\n  var l = getHeaders(n[0]);\n  return l.length ? {\n    data: n.slice(1).map(transformCells).map(function (e) {\n      return l.reduce(function (t, r, a) {\n        return t[camelCase(r)] = e[a], t;\n      }, {});\n    }),\n    end: r + a\n  } : null;\n},\n    parseTables = function (e) {\n  for (var t = [], r = e, a = null; a = getNextTable(r);) {\n    if (!a) return t;\n    t.push(a.data), r = r.substring(a.end);\n  }\n\n  return t;\n},\n    headingPattern = /[^=]==\\s?([\\w\\s]+)\\s?==/g,\n    subheadingPattern = /===([\\w\\s]+)===/g,\n    tableStartPattern$1 = /{{list.+start.*}}/gi,\n    tableEndPattern$1 = /{{list.+end.*}}/gi,\n    rowPattern$1 = /{{(.*)}}/g,\n    rowPatternSingle = /{{(.*)}}/,\n    parseLists = function (e) {\n  var t = getMatches(e, headingPattern),\n      r = getMatches(e, subheadingPattern),\n      a = getTables(e);\n  return a.forEach(function (e) {\n    var a = t.filter(function (t) {\n      return t.end < e.start;\n    }).map(function (e) {\n      return e.value;\n    });\n    e.heading = last(a);\n    var n = r.filter(function (t) {\n      return t.end < e.start;\n    }).map(function (e) {\n      return e.value;\n    });\n    e.subheading = last(n), delete e.start, delete e.end;\n  }), a;\n},\n    index = function (e, t) {\n  var r = extractInfoboxes(e).map(function (e) {\n    return transformProperties(extractProperties(extractData(cleanSource(e)), t));\n  });\n  if (!r.length) return {};\n  var a = {\n    general: r.shift()\n  };\n  return r.forEach(function (e) {\n    var t = e.type;\n    t ? a[camelCase(t)] = e : Object.assign(a, {\n      general: Object.assign({}, a.general, e)\n    });\n  }), a.tables = parseTables(e), a.lists = parseLists(e), a;\n};\n\nmodule.exports = index;","map":{"version":3,"sources":["../util/getValue.js","../data-types/dataType.js","../util/extractData.js","../util/propertyList.js","../util/extractProperties.js","../util/transformProperties.js","../util/extractInfoboxes.js","../util/cleanSource.js","../util/parseTables.js","../util/parseLists.js","../data-types/small.js","../data-types/flag.js","../data-types/coords.js","../data-types/instances.js","../data-types/unbulletedLists.js","../data-types/unmarkedLists.js","../data-types/plainLists.js","../data-types/marriages.js","../data-types/other.js","../data-types/birthDates.js","../data-types/labeledDates.js","../data-types/deathDates.js","../data-types/url.js","../data-types/website.js","../data-types/convert.js","../data-types/index.js","../util/numberParse.js","../index.js"],"names":["extraPropertyPattern","endingPattern","linksPattern","linkSeparatorPattern","trimWrappers","str","replace","trim","trimOr","orPosition","indexOf","substring","getValue","raw","key","cleansed","links","match","split","filter","text","DO_NOT_REPLACE","Symbol","dataType","globalPattern","parsePattern","parse","variable","name","matches","source","instances","map","sourceAfter","reduce","memo","index","byDataHandler","context","handler","data","Object","assign","extractData","dataTypes","type","keyValueGlobalPattern","keyValuePattern","findPropertyList","keyValuePairs","result","exec","rawKey","rawValue","camelCase","item","smallDataType","find","fillVariables","value","simplifyDataValues","log","JSON","stringify","pattern","matched","dataValue","parseInt","fillVariablesUntilDone","options","undefined","Date","Array","isArray","keys","filled","handleSmallData","primary","secondary","getVariableValue","smallData","reduceVariable","float","numberParse","parseFloat","isNaN","dateValue","variableValue","byVariableReduction","reduced","extractProperties","blankNamePattern","blankInfoPattern","transformProperties","properties","transformed","id","blankName","blankInfo","findOuterIndex","lastOpen","i","length","nextTwo","substr","push","pop","infoBoxStartPattern","startMatch","sourceLeft","startIndex","withStart","outerIndex","extractInfoboxes","parsed","infoboxes","cleanSource","tableStartPattern","tableEndPattern","headersPattern","rowPattern","cellSeparatorPattern","linkPattern","linkNamePattern","inlineHeaderPattern","actionPattern","ticks","rowSpanCountPattern","stripLinks","m","capture","removeActions","transformCell","transformCells","row","findIndex","t","p","findTableStart","findTableEnd","getHeaders","headers","transformRowSpan","rows","merged","cells","k","o","join","getRows","e","spanN","spanCount","rowsInSpan","getNextTable","left","start","end","slice","obj","camelcase","tables","headingPattern","subheadingPattern","rowPatternSingle","getMatches","parseTableData","el","getTables","tableStarts","tableEnds","tableStart","tableEnd","Error","last","list","headings","subheadings","forEach","headingsBefore","heading","table","subheadingsBefore","subheading","smallGlobalPattern","smallPattern","results","flagGlobalPattern","flagPattern","coordsGlobalPattern","coordsPattern","listItemPrefixPattern","unbulletedListGlobalPattern","unbulletedListItemPattern","listItems","plainListGlobalPattern","plainListItemPattern","marriageGlobalPattern","marriagePattern","otherGlobalPattern","otherPattern","label","birthDateGlobalPattern","birthDatePattern","millisInYear","year","month","day","date","Math","floor","now","labeledDateGlobalPattern","labeledDatePattern","firstPipeIndex","potentialDate","getTime","deathDateGlobalPattern","deathDatePattern","deathYear","deathMonth","deathDay","birthYear","birthMonth","birthDay","deathDate","birthDate","Number","URLGlobalPattern","URLPattern","websiteGlobalPattern","websitePattern","protocol","hostname","path","convertGlobalPattern","convertPattern","small","flag","coords","marriages","birthDates","labeledDates","deathDates","unbulletedLists","website","url","convert","other","plainLists","unmarkedLists","createDataTypeHandler","RegExp","number","parseEnglish","parseSpanish","toString","infobox","res","shift","next","general","parseTables","lists","parseLists"],"mappings":"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","sourcesContent":["const extraPropertyPattern = /\\n?\\s?\\|\\s?\\w+$/;\nconst endingPattern = /\\n\\}\\}$/;\nconst linksPattern = /((\\$\\w+_\\d+)\\s*,?\\s*){2,}/g;\nconst linkSeparatorPattern = /[,\\s?]/g;\n\nfunction trimWrappers(str) {\n  return str\n    .replace(/\\[\\[/g, '')\n    .replace(/\\]\\]/g, '')\n    .replace(/\\{\\{/g, '')\n    .replace(/\\}\\}/g, '')\n    .trim();\n}\n\nfunction trimOr(str) {\n  const orPosition = str.indexOf('|');\n  if (orPosition !== -1) {\n    return str.substring(0, orPosition);\n  }\n  return str;\n}\n\nexport default function getValue(raw, key) {\n  if (!raw) {\n    return null;\n  }\n\n  const cleansed = raw\n    .trim()\n    .replace(/File:/, '')\n    // Have not found reason for this but it breaks parsing, so we are just\n    // removing it for now\n    .replace(/\\{\\{\\d+\\}\\}/g, '')\n    .replace(extraPropertyPattern, '')\n    .replace(endingPattern, '');\n\n  if (cleansed === 'y' || cleansed === 'yes') {\n    return true;\n  }\n\n  if (key == 'birthPlace') {\n    return raw.trim();\n  }\n\n  // Is it a list of links??\n  const links = cleansed.match(linksPattern);\n  if (links) {\n    return links[0].split(linkSeparatorPattern).filter(text => text);\n  }\n\n  return trimOr(trimWrappers(cleansed));\n}\n","export const DO_NOT_REPLACE = Symbol('DO NOT REPLACE');\n\nexport default function dataType({ globalPattern, parsePattern, parse, variable, name }) {\n  return source => {\n    const matches = source.match(globalPattern);\n    if (!matches) {\n      return {\n        [name]: [],\n        sourceAfter: source,\n      }\n    }\n    const instances = matches.map(match => parse(match.match(parsePattern)));\n    const sourceAfter = matches.reduce((memo, match, index) => {\n      if (instances[index] === DO_NOT_REPLACE) {\n        return memo;\n      }\n      return memo.replace(match, `$${variable}_${index}`);      \n    }, source);\n    return {\n      data: {\n        [name]: instances,\n      },\n      sourceAfter,\n    };\n  };\n}\n","import dataTypes from '../data-types/index';\n\nfunction byDataHandler({ source, context }, handler) {\n  const { data, sourceAfter } = handler(source);\n  return {\n    context: Object.assign({}, context, data),\n    source: sourceAfter,\n  };\n}\n\nexport default function extractData(source) {\n  return dataTypes\n    .map(type => type.handler)\n    .reduce(byDataHandler, {\n      context: {},\n      source,\n    });\n}\n","import getValue from './getValue';\nimport camelCase from 'camelcase';\n\nconst keyValueGlobalPattern = /\\|\\s*([-'\\u0400-\\u04FF\\w\\s]+)\\s*=\\s*([^|]+)?/g;\nconst keyValuePattern = /\\|\\s*([-'\\u0400-\\u04FF\\w\\s]+)\\s*=\\s*([^|]+)?/;\n\nexport default function findPropertyList(source) {\n  const keyValuePairs = source.match(keyValueGlobalPattern);\n  if (!keyValuePairs) {\n    return [];\n  }\n  return keyValuePairs\n    .map(match => {\n      const result = keyValuePattern.exec(match);\n      if (!result) {\n        return null;\n      }\n      const [, rawKey, rawValue] = result;\n      const key = camelCase(rawKey.trim());\n      return {\n        key,\n        value: getValue(rawValue, key),\n      };\n    })\n    .filter(item => item);\n}\n","import dataTypes from '../data-types/index';\nimport findPropertyList from './propertyList';\nimport numberParse from './numberParse'\n\nconst smallDataType = dataTypes.find(type => type.name === 'smalls');\n\nfunction fillVariables(value, context, { simplifyDataValues }) {\n  if (typeof value !== 'string') {\n    console.log(`Warning: Something went wrong. Could not fill variables in: (${typeof value}) ${JSON.stringify(value)}`);\n    return {};\n  }\n  const dataType = dataTypes.find(type => value.match(type.pattern));\n  if (dataType) {\n    const [matched, index] = dataType.pattern.exec(value);\n    const dataValue = context[dataType.name][parseInt(index, 10)];\n    if (!simplifyDataValues && typeof dataValue === 'string') {\n      return value.replace(matched, dataValue);\n    }\n    return dataValue;\n  }\n  return value;\n}\n\n// Recursive varaible filling... even handles arrays of values\nfunction fillVariablesUntilDone(value, context, options) {\n  if (value === undefined) {\n    return value;\n  }\n  if (value instanceof Date) {\n    return value;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map(item => fillVariablesUntilDone(item, context, options));\n  }\n  if (typeof value === 'object') {\n    return Object.keys(value).reduce((memo, key) => {\n      return Object.assign(memo, {\n        [key]: fillVariablesUntilDone(value[key], context, options)\n      });\n    }, {});\n    // return value.map(item => fillVariablesUntilDone(item, context, options));\n  }\n  const filled = fillVariables(value, context, options);\n  if (filled === value) {\n    return value;\n  }\n  return fillVariablesUntilDone(filled, context, options);\n}\n\nfunction handleSmallData(value, context, { simplifyDataValues }) {\n  if (typeof value === 'string' && value.match(smallDataType.pattern)) {\n    const primary = value\n      .replace(smallDataType.pattern, '')\n      // Cleaning up from inserted commas\n      .replace(/,/, '')\n      .trim();\n    const [, index] = smallDataType.pattern.exec(value);\n    const secondary = context[smallDataType.name][parseInt(index, 10)];\n    const result = {\n      primary: getVariableValue(primary, context, { simplifyDataValues }),\n      secondary: getVariableValue(secondary, context, { simplifyDataValues }),\n    };\n    return simplifyDataValues ? result.primary : result;\n  }\n  return null;\n}\n\nfunction getVariableValue(value, context, { simplifyDataValues = true } = {}) {\n  // Handling small data differently... I dont like this...\n  const smallData = handleSmallData(value, context, { simplifyDataValues });\n  if (smallData) {\n    return smallData;\n  }\n  return fillVariablesUntilDone(value, context, { simplifyDataValues });\n}\n\nfunction reduceVariable(key, value, context, options) {\n  if (value === null) {\n    return null;\n  }\n  if (typeof value === 'boolean') {\n    return value;\n  }\n  // First array pass...\n  if (Array.isArray(value)) {\n    return value.map(item => getVariableValue(item, context, options));\n  }\n  if (key.match(/areaTotal/) || key.match(/population/)) {\n    let float = numberParse(value);\n    if (float === false) float = parseFloat(value, 10);\n    if (!isNaN(float)) {\n      return float;\n    }\n  }\n  if (key.match(/date/i)) {\n    const dateValue = +new Date(value);\n    if (!isNaN(dateValue)) {\n      return new Date(value);\n    }\n  }\n  const variableValue = getVariableValue(value, context, options);\n\n  // Second array pass. If first variable was an array of variables.\n  if (Array.isArray(variableValue)) {\n    return variableValue.map(item => getVariableValue(item, context, options));\n  }\n  return variableValue;\n}\n\nfunction byVariableReduction(context, options) {\n  return (memo, { key, value }) => {\n    const reduced = reduceVariable(key, value, context, options);\n    if (reduced === '' || reduced === null) {\n      return memo;\n    }\n    return Object.assign({}, memo, {\n      [key]: reduced,\n    });\n  }\n}\n\nexport default function extractProperties({ source, context }, options) {\n  return findPropertyList(source).reduce(byVariableReduction(context, options), {});\n}\n","// import getValue from './getValue';\nimport camelCase from 'camelcase';\n\nconst blankNamePattern = /blank(\\d+)?NameSec2/;\nconst blankInfoPattern = /blank(\\d+)?InfoSec2/;\n\nexport default function transformProperties(properties) {\n  return Object.keys(properties)\n    .reduce((transformed, key) => {\n      const value = properties[key];\n      const match = key.match(blankNamePattern);\n      if (match) {\n        const id = match[1] || '';\n        const blankName = properties[`blank${id}NameSec2`];\n        const blankInfo = properties[`blank${id}InfoSec2`];\n        if (typeof blankName !== 'string') return transformed;\n        return Object.assign(transformed, {\n          [camelCase(blankName)]: blankInfo,\n        });\n      }\n      if (key.match(blankInfoPattern)) {\n        return transformed;\n      }\n      return Object.assign(transformed, {\n        [key]: value,\n      });\n    }, {});\n}\n","function findOuterIndex(source) {\n\tlet lastOpen = [];\n\tfor (let i = 0; i < source.length - 1; i++) {\n    const nextTwo = source.substr(i, 2);\n    if (nextTwo === '{{') {\n\t\t\tlastOpen.push(i);\n\t\t\t// Move forward, so we do not count closures right next to each other\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n    if (nextTwo === '}}') {\n\t\t\tconst openAt = lastOpen.pop();\n\t\t\tif (lastOpen.length === 0) {\n\t\t\t\t// Adding 2 here for the closure\n\t\t\t\treturn i + 2;\n\t\t\t}\n\t\t\t// Move forward, so we do not count closures right next to each other\n\t\t\ti++;\n\t\t}    \n  }\n}\n\nconst infoBoxStartPattern = /{{\\w*box/;\n\nfunction parse(source) {\n\tconst startMatch = source.match(infoBoxStartPattern);\n\tif (!startMatch) {\n\t\t// May not have a a proper infobox wrapper, let's use the entire source\n\t\t// by default\n\t\treturn { data: source, sourceLeft: null };\n\t}\n\tconst startIndex = startMatch.index;\n\tconst withStart = source.substring(startIndex);\n\tconst outerIndex = findOuterIndex(withStart);\n\tif (!outerIndex) {\n\t\treturn { data: source, sourceLeft: null };\n\t}\n\tconst data = withStart.substring(0, outerIndex);\n\tconst sourceLeft = source.substring(outerIndex);\n\tconst sourceLeftHasMatch = !!sourceLeft.match(infoBoxStartPattern);\n\treturn {\n\t\tdata,\n\t\tsourceLeft: sourceLeftHasMatch ? sourceLeft : null\n\t};\n}\n\nexport default function extractInfoboxes(source) {\n  let parsed = parse(source);\n  const infoboxes = [parsed.data];\n  while(parsed.sourceLeft) {\n  \tparsed = parse(parsed.sourceLeft);\n  \tinfoboxes.push(parsed.data);\n  }\n  return infoboxes;\n}\n","export default function cleanSource(source) {\n\treturn source\n    .replace(/''/g, '')\n    .replace(/\\|display=inline/g, '')\n    // This is a little iffy\n    .replace(/<br\\s?\\/?>/g, ',')\n    .replace(/<ref(\\s\\w+=[^>]+)?>.*<\\/ref>/g, '')\n    .replace(/&minus;/g, '-')\n    .replace(/<sup>/g, '^')\n    // Remove shortened footnote templates\n    .replace(/\\{\\{sfn\\|([^\\}\\}]+)\\}\\}/g, '')\n    // Remove explanatory footnotes\n    .replace(/\\{\\{efn\\|([^\\}\\}]+)\\}\\}/g, '')\n    .replace(/âˆ’/g, '-')\n    .replace(/<\\/sup>/g, '')\n    .replace(/<ref(\\s\\w+=[^>]+)?\\s?\\/>/g, '')\n    // HTML comments\n    .replace(/<!--([\\s\\S]*?)-->/g, '')\n    .replace(/&nbsp;/g, ' ')\n    .replace('|\\'\\'See list\\'\\'', '');\n}\n","import camelcase from 'camelcase';\n\nconst tableStartPattern = /{\\|(.*)\\n?/;\nconst tableEndPattern = /\\n\\|}/;\nconst headersPattern = /!\\s?(.*)/g;\nconst rowPattern = /\\|-/;\nconst cellSeparatorPattern = /(?:\\n\\|)|(?:\\|\\|)/;\nconst linkPattern = /\\[\\[([^\\]]+)\\]\\]/g;\nconst linkNamePattern = /^.*\\|/;\nconst inlineHeaderPattern = '!!';\nconst actionPattern = /{{anchor\\|(.*)}}/g;\nconst ticks = /'''/g;\nconst rowSpanCountPattern = /rowspan=\"(\\d+)\"/;\n\nconst stripLinks = source => source.replace(linkPattern, (m, capture) => {\n    const result = capture.replace(linkNamePattern, '').trim();\n    return result || capture;\n})\nconst removeActions = source => source.replace(actionPattern, '')\nconst transformCell = source => stripLinks(removeActions(source || ''))\n    .replace(rowSpanCountPattern, '')\n    .replace(linkNamePattern, '')\n    .replace(ticks, '')\n    .trim()\n\nconst transformCells = row => row.split(cellSeparatorPattern).map(transformCell)\n\nconst findIndex = (t, p) => {\n    const m = t.match(p);\n    return m ? m.index : -1;\n}\n\nconst findTableStart = source => {\n    const m = source.match(tableStartPattern);\n    return m ? m.index + m[0].length : -1;\n}\nconst findTableEnd = source => findIndex(source, tableEndPattern)\n\nconst getHeaders = source => {\n    const headers = [];\n    let match;\n    while (match = headersPattern.exec(source)) {\n        headers.push(...match[1].split(inlineHeaderPattern).map(transformCell));\n    }\n    return headers;\n}\n\nfunction transformRowSpan(rows) {\n    return rows\n        .map(transformCells)\n        .reduce((merged, cells, index) => {\n            const k = index === 0 ? 0 : 1;\n            for (let i = 0; i < cells.length; i++) {\n                if (!merged[i + k]) merged[i + k] = {};                        \n                if (cells[i]) {\n                    merged[i + k][cells[i]] = 1;\n                }\n            }\n            return merged;\n        }, [])\n        .map(o => Object.keys(o).join(','))\n        .join(' || ');\n}\n\nconst getRows = source => {\n    const raw = source\n        .split(rowPattern)\n        .map(e => e.replace(/^.*\\n+?\\|/, '').trim())\n        .filter(e => e);\n\n    const rows = [];\n    let spanN = 0;\n    let spanCount = 0;\n    let rowsInSpan = [];\n\n    for (const row of raw ){\n        const match = row.match(rowSpanCountPattern);\n        if (match) {\n            spanN = 0;\n            spanCount = parseInt(match[1]);\n            rowsInSpan = [];\n        }\n        if (spanN < spanCount) {            \n            rowsInSpan.push(row);\n            if (++spanN === spanCount) {\n                rows.push(transformRowSpan(rowsInSpan));\n            }\n        }else {\n            rows.push(row)\n        }\n    }\n\n    return rows;\n}\n    \nconst getNextTable = source => {\n    let left = source;\n    const start = findTableStart(left);\n    \n    if (start === -1) return null;    \n    left = left.substring(start);\n    \n    const end = findTableEnd(left);\n\n    if (end === -1) return null;\n    left = left.substring(0, end);\n\n    const rows = getRows(left);\n\n    if (!rows.length) return null;\n    \n    const headers = getHeaders(rows[0]);\n\n    if (!headers.length) return null;\n\n    const data = rows.slice(1).map(transformCells).map(row => {\n        return headers.reduce((obj, key, index) => {\n            obj[camelcase(key)] = row[index];\n            return obj;\n        }, {});\n    });\n\n    return { data, end: start + end };\n}\n\nexport default function (source) {\n    const tables = [] ;\n    let left = source;\n    let result = null;\n    while(result = getNextTable(left)) {\n        if (!result) {\n            return tables;\n        }        \n        tables.push(result.data);\n        left = left.substring(result.end);\n    }\n\treturn tables;\n}\n","const headingPattern = /[^=]==\\s?([\\w\\s]+)\\s?==/g\nconst subheadingPattern = /===([\\w\\s]+)===/g\nconst tableStartPattern = /{{list.+start.*}}/gi\nconst tableEndPattern = /{{list.+end.*}}/gi\nconst rowPattern = /{{(.*)}}/g\nconst rowPatternSingle = /{{(.*)}}/\n\nfunction getHeadings(text) {\n\tlet match;\n\tconst headings = [];\n\twhile ((match = headingPattern.exec(text)) !== null) {\n\t\theadings.push({\n\t\t\theading: match[1].trim(),\n\t\t\tstart: match.index,\n\t\t\tend: match.index + match[0].length\n\t\t})\n\t}\n\treturn headings;\n}\n\nfunction getSubheadings(text) {\n\tlet match;\n\tconst subheadings = [];\n\twhile ((match = subheadingPattern.exec(text)) !== null) {\n\t\tsubheadings.push({\n\t\t\theading: match[1].trim(),\n\t\t\tstart: match.index,\n\t\t\tend: match.index + match[0].length\n\t\t})\n\t}\n\treturn subheadings;\n}\n\nfunction getMatches(text, pattern) {\n\tlet match;\n\tconst matches = [];\n\twhile ((match = pattern.exec(text)) !== null) {\n\t\tmatches.push({\n\t\t\tvalue: match[1] && match[1].trim(),\n\t\t\tstart: match.index,\n\t\t\tend: match.index + match[0].length\n\t\t})\n\t}\n\treturn matches;\n}\n\nfunction parseTableData(raw) {\n\tconst matches = raw.match(rowPattern);\n\tif (!matches) return [];\n\treturn matches.map(el => {\n\t\tconst [,text] = el.match(rowPatternSingle);\n\t\tconst columns = text.trim().split('|');\n\t\treturn columns.slice(1);\n\t});\n}\n\nfunction getTables(text) {\n\tconst tableStarts = getMatches(text, tableStartPattern);\n\tconst tableEnds = getMatches(text, tableEndPattern);\n\treturn tableStarts.map((tableStart, index) => {\n\t\tconst tableEnd = tableEnds[index];\n\t\tif (!tableEnd) {\n\t\t\tthrow new Error('[Table Parsing] Failed to pair table');\n\t\t}\n\t\tconst raw = text\n\t\t\t\t.substring(tableStart.end, tableEnd.start)\n\t\t\t\t.trim()\n\t\t\t\t.replace(/'''/g, '');\n\t\treturn {\n\t\t\trows: parseTableData(raw),\n\t\t\tstart: tableStart.start,\n\t\t\tend: tableEnd.end\n\t\t}\n\t});\n}\n\nfunction last(list) {\n\treturn list.length ? list[list.length - 1] : undefined;\n}\n\nexport default function (source) {\n\tconst headings = getMatches(source, headingPattern);\n\tconst subheadings = getMatches(source, subheadingPattern);\n\tconst tables = getTables(source);\n\n\ttables.forEach(table => {\n\t\tconst headingsBefore = headings.filter(heading => {\n\t\t\treturn heading.end < table.start;\n\t\t}).map(e => e.value)\n\t\ttable.heading = last(headingsBefore);\n\t\tconst subheadingsBefore = subheadings.filter(subheading => {\n\t\t\treturn subheading.end < table.start;\n\t\t}).map(e => e.value)\n\t\ttable.subheading = last(subheadingsBefore);\n\t\tdelete table.start;\n\t\tdelete table.end;\n\t});\n\n\treturn tables;\n}","const smallGlobalPattern = /\\{\\{small\\|([^\\}\\}]+)\\}\\}/g;\nconst smallPattern = /small\\|([^\\}\\}]+)\\}\\}/;\n\nexport default {\n  globalPattern: smallGlobalPattern,\n  parsePattern: smallPattern,\n  parse: results => {\n    const [, value] = results;\n    return value;\n  },\n  variable: 'SMALL',\n  name: 'smalls',\n};\n","const flagGlobalPattern = /\\{\\{flag\\|([^\\}\\}]+)\\}\\}/g;\nconst flagPattern = /flag\\|([^\\}\\}]+)\\}\\}/;\n\nexport default {\n  globalPattern: flagGlobalPattern,\n  parsePattern: flagPattern,\n  parse: results => {\n    const [, value] = results;\n    return value;\n  },\n  variable: 'FLAG',\n  name: 'flags',\n};\n","const coordsGlobalPattern = /\\{\\{coord\\|([^\\}\\}]+)\\}\\}/g;\nconst coordsPattern = /coord\\|([^\\}\\}]+)\\}\\}/;\n\nexport default {\n  globalPattern: coordsGlobalPattern,\n  parsePattern: coordsPattern,\n  parse: results => {\n    const [, value] = results;\n    return value;\n  },\n  variable: 'COORD',\n  name: 'coords',\n};\n","const globalPattern = /\\[\\[([^\\]\\|]+)\\|?([^\\]]+)?\\]\\]/g;\nconst pattern = /\\[\\[([^\\]\\|]+)\\|?([^\\]]+)?\\]\\]/;\n\nexport default {\n  globalPattern: globalPattern,\n  parsePattern: pattern,\n  parse: results => {\n    const [, value, type] = results;\n    return value || type;\n  },\n  variable: 'INSTANCE',\n  name: 'instances',\n};\n","import getValue from '../util/getValue';\n\nconst listItemPrefixPattern = /^\\|\\s?/;\nconst unbulletedListGlobalPattern = /\\{\\{(?:unbulleted list|ubl|ubt|ublist|unbullet)\\s?\\|([^\\}\\}]+)\\}\\}/g;\nconst unbulletedListItemPattern = /\\|\\s*([^|}]+)/g;\n\nexport default {\n  globalPattern: unbulletedListGlobalPattern,\n  parsePattern: unbulletedListItemPattern,\n  parse: listItems => {\n    if (!listItems) {\n      return [];\n    }\n    return listItems\n      .map(item => item.replace(listItemPrefixPattern, '').trim())\n      .filter(value => value && value.length);\n  },\n  variable: 'UNBULLETED_LIST',\n  name: 'unbulletedLists',\n};\n","const listItemPrefixPattern = /^\\*\\s*/;\nconst plainListGlobalPattern = /\\n(\\*\\s*[^*|]+)+/g;\nconst plainListItemPattern = /\\*\\s*([^*|]+)/g;\n\nexport default {\n  globalPattern: plainListGlobalPattern,\n  parsePattern: plainListItemPattern,\n  parse: listItems => {\n    if (!listItems) {\n      return [];\n    }\n    return listItems\n      .map(item => item.replace(listItemPrefixPattern, '').trim())\n      .filter(value => value && value.length);\n  },\n  variable: 'UNMARKED_LIST',\n  name: 'unmarkedLists',\n};\n","import getValue from '../util/getValue';\n\nconst listItemPrefixPattern = /^\\*\\s?/;\nconst plainListGlobalPattern = /\\{\\{f?p?P?l?a?i?n?t?list\\s?\\|([^\\}\\}]+)\\}\\}/g;\nconst plainListItemPattern = /\\*\\s*([^*}]+)/g;\n\nexport default {\n  globalPattern: plainListGlobalPattern,\n  parsePattern: plainListItemPattern,\n  parse: listItems => {\n    if (!listItems) {\n      return [];\n    }\n    return listItems\n      .map(item => item.replace(listItemPrefixPattern, '').trim())\n      // .map(getValue)\n      .filter(value => value && value.length);\n  },\n  variable: 'PLAIN_LIST',\n  name: 'plainLists',\n};\n","const marriageGlobalPattern = /\\{\\{Marriage\\|([^\\}\\}]+)\\}\\}/g;\nconst marriagePattern = /Marriage\\|([^|]+)\\|(.*)\\}\\}/;\n\nexport default {\n  globalPattern: marriageGlobalPattern,\n  parsePattern: marriagePattern,\n  parse: results => {\n    const [, who, married] = results;\n    return {\n      who,\n      married,\n    };\n  },\n  variable: 'MARRIAGE',\n  name: 'marriages',\n};\n","const otherGlobalPattern = /\\{\\{([^|\\n]+)\\|([^|\\n]+)\\|?([^\\}\\n]+)?\\}\\}/g;\nconst otherPattern = /\\{\\{([^|\\n]+)\\|([^|\\n]+)\\|?([^\\}\\n]+)?\\}\\}/;\n\nexport default {\n  globalPattern: otherGlobalPattern,\n  parsePattern: otherPattern,\n  parse: results => {\n    const [, label, descriptor, extra] = results;\n    return label;\n  },\n  variable: 'OTHER',\n  name: 'others',\n};\n","const birthDateGlobalPattern = /\\{\\{birth\\sdate([^\\}\\}]+)\\}\\}/ig;\nconst birthDatePattern = /(\\d+)\\|(\\d+)\\|(\\d+)/;\n\nconst millisInYear = 1000 * 60 * 60 * 24 * 365;\n\nexport default {\n  globalPattern: birthDateGlobalPattern,\n  parsePattern: birthDatePattern,\n  parse: results => {\n    const [, year, month, day] = results;\n    const date = new Date(year, month-1, day);\n    const age = Math.floor((Date.now() - +date) / millisInYear);\n    return {\n      date,\n      age,\n    };\n  },\n  variable: 'BIRTH_DATE',\n  name: 'birthDates',\n};\n","import { DO_NOT_REPLACE } from './dataType'\nconst labeledDateGlobalPattern = /\\{\\{([^\\n\\}\\}]+)\\}\\}/g;\nconst labeledDatePattern = /(.*)/;\n\nexport default {\n  globalPattern: labeledDateGlobalPattern,\n  parsePattern: labeledDatePattern,\n  parse: results => {\n    const firstPipeIndex = results[0].indexOf('|');\n    if (firstPipeIndex > -1) {\n      const str = results[0]\n        .substring(firstPipeIndex + 1)\n        .slice(0, -2)\n      let potentialDate = new Date(str + ' GMT');\n      if (!isNaN(potentialDate.getTime())) {\n        return { date: potentialDate };\n      }\n      potentialDate = new Date(str.split('|').join('-') + ' GMT')\n      if (!isNaN(potentialDate.getTime())) {\n        return { date: potentialDate };\n      }\n    }\n    return DO_NOT_REPLACE;\n  },\n  variable: 'LABELED_DATE',\n  name: 'labeledDates',\n};\n","const deathDateGlobalPattern = /\\{\\{death\\sdate\\sand\\sage([^\\}\\}]+)\\}\\}/ig;\nconst deathDatePattern = /(\\d+)\\|(\\d+)\\|(\\d+)\\|(\\d+)\\|?(\\d+)?\\|?(\\d+)?/;\n\nconst millisInYear = 1000 * 60 * 60 * 24 * 365;\n\nexport default {\n  globalPattern: deathDateGlobalPattern,\n  parsePattern: deathDatePattern,\n  parse: results => {\n    // Some articles do not list birth month/day so we just estimate the birth date\n    const [, deathYear, deathMonth, deathDay, birthYear, birthMonth = 0, birthDay = 0] = results;\n    const deathDate = new Date(deathYear, deathMonth-1, deathDay);\n    const birthDate = new Date(birthYear, birthMonth-1, birthDay);\n    const age = Math.floor((Number(deathDate) - Number(birthDate)) / millisInYear);\n    return {\n      date: deathDate,\n      age,\n    };\n  },\n  variable: 'DEATH_DATE',\n  name: 'deathDates',\n};\n","const URLGlobalPattern = /\\{\\{URL\\|([^\\}\\}]+)\\}\\}/g;\nconst URLPattern = /URL\\|([^\\}\\}]+)\\}\\}/;\n\nexport default {\n  globalPattern: URLGlobalPattern,\n  parsePattern: URLPattern,\n  parse: results => {\n    const [, value] = results;\n    return value;\n  },\n  variable: 'URL',\n  name: 'urls',\n};\n","const websiteGlobalPattern = /\\[(https?):\\/\\/((?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6})\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)\\s+([\\w\\s]+)\\]/g;\nconst websitePattern = /\\[(https?):\\/\\/((?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6})\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)\\s+([\\w\\s]+)\\]/;\n\nexport default {\n  globalPattern: websiteGlobalPattern,\n  parsePattern: websitePattern,\n  parse: results => {\n    const [, protocol, hostname, path, title] = results;\n    return {\n      protocol,\n      hostname,\n      path,\n      title,\n      url: `${protocol}://${hostname}${path}`\n    };\n  },\n  variable: 'WEBSITE',\n  name: 'websites',\n};\n","const convertGlobalPattern = /\\{\\{convert\\|([\\d\\.]+)\\|(\\w+)/g;\nconst convertPattern = /\\{\\{convert\\|([\\d\\.]+)\\|(\\w+)/;\n\nexport default {\n  globalPattern: convertGlobalPattern,\n  parsePattern: convertPattern,\n  parse: results => {\n    const [, num, unit] = results;\n    return `${num} ${unit}`;\n  },\n  variable: 'CONVERT',\n  name: 'converts',\n};\n","import small from './small';\nimport flag from './flag';\nimport coords from './coords';\nimport instances from './instances';\nimport unbulletedLists from './unbulletedLists';\nimport unmarkedLists from './unmarkedLists';\nimport plainLists from './plainLists';\nimport marriages from './marriages';\nimport other from './other';\nimport birthDates from './birthDates';\nimport labeledDates from './labeledDates';\nimport deathDates from './deathDates';\nimport url from './url';\nimport website from './website';\nimport convert from './convert';\nimport createDataTypeHandler from './dataType';\n\nconst dataTypes = [\n  // Order is very important here...\n  instances,\n  small,\n  flag,\n  coords,\n  marriages,\n  birthDates,\n  labeledDates,\n  deathDates,\n  unbulletedLists,\n  website,\n  url,\n  convert,\n  // other needs to always be after specific data dypes\n  other,\n  // Lists should be last\n  plainLists,\n  unmarkedLists,\n];\n\nexport default dataTypes.map(type => {\n  return {\n    handler: createDataTypeHandler(type),\n    name: type.name,\n    pattern: new RegExp(`\\\\$${type.variable}_(\\\\d+)`),\n  };\n});\n","\n/**\n * Given a string meant to contain a number, tries to find out\n * the number considering comma or point separators\n * @param  {String} number\n * @return {Number} with the parsed number, false, if the parsing is\n *                  not possible\n */\nexport default (number) => {\n\n  if (typeof number !== 'string') return false\n\n  number = number.trim().replace(/ /g, '')\n\n  // Find out if commas are used as thousand or decimal separators.\n  // If the string has both, and commas are first, then commas are\n  // thousand separators (english style)\n  if (number.match(/,/) && number.match(/\\./)) {\n    if (number.indexOf(',') < number.indexOf('.')) {\n      return parseEnglish(number)\n    } else {\n      return parseSpanish(number)\n    }\n  }\n\n  if (number.match(/,/) && !number.match(/\\./)) {\n    if (number.match(/,/g).length > 1) {\n\n      // If there is more than one, then it's a thousand separator\n      return parseEnglish(number)\n    } else {\n\n      // If it's follwed by 3 digits, it's proably a thousand separator\n      if (number.match(/,[0-9]{3}($|^[0-9])/)) {\n        return parseEnglish(number)\n      } else {\n        return parseSpanish(number)\n      }\n\n    }\n  }\n\n  if (!number.match(/,/) && number.match(/\\./)) {\n    if (number.match(/\\./g).length > 1) {\n\n      // If there is more than one, then it's a thousand separator\n      return parseSpanish(number)\n    } else {\n\n      // If it's follwed by 3 digits, it's proably a thousand separator\n      if (number.match(/\\.[0-9]{3}($|^[0-9])/)) {\n        return parseSpanish(number)\n      } else {\n        return parseEnglish(number)\n      }\n\n    }\n  }\n\n  // If it looks the same as number or string, just cast it\n  if ((+number).toString() === number) return +number\n\n  return false\n}\n\nconst parseEnglish = (str) => {\n  return +str.replace(/,/g, '')\n}\n\nconst parseSpanish = (str) => {\n  return +str.replace(/\\./g, '').replace(/,/g, '.')\n}\n\n","import camelCase from 'camelcase';\nimport extractData from './util/extractData';\nimport extractProperties from './util/extractProperties';\nimport transformProperties from './util/transformProperties';\nimport extractInfoboxes from './util/extractInfoboxes';\nimport cleanSource from './util/cleanSource';\nimport parseTables from './util/parseTables';\nimport parseLists from './util/parseLists';\n\nexport default function (source, options) {\n\tconst infoboxes = extractInfoboxes(source).map(infobox => {\n\t  const cleanedSource = cleanSource(infobox);\n\t  const data = extractData(cleanedSource);\n\t  const props = extractProperties(data, options);\n\t  return transformProperties(props);  \t\n  });\n\n  if (!infoboxes.length) return {};\n\n  const res = {\n  \t// First infobox should be the main one\n  \tgeneral: infoboxes.shift()\n  };\n\n  infoboxes.forEach(next => {\n  \tconst type = next.type;\n\t\tif (type) {\n\t\t\tres[camelCase(type)] = next;\n\t\t} else {\n\t\t\tObject.assign(res, {\n\t\t\t\tgeneral: Object.assign({}, res.general, next)\n\t\t\t});\n\t\t}\n\t});\n\n\tres.tables = parseTables(source);\n\tres.lists = parseLists(source);\n\n\treturn res;\n};\n"]},"metadata":{},"sourceType":"script"}
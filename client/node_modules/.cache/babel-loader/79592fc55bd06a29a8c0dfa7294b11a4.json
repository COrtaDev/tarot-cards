{"ast":null,"code":"'use strict';\n/*\n * Displays a helpful message and the source of\n * the format when it is invalid.\n */\n\nclass InvalidFormatError extends Error {\n  constructor(formatFn) {\n    super(`Format functions must be synchronous taking a two arguments: (info, opts)\nFound: ${formatFn.toString().split('\\n')[0]}\\n`);\n    Error.captureStackTrace(this, InvalidFormatError);\n  }\n\n}\n/*\n * function format (formatFn)\n * Returns a create function for the `formatFn`.\n */\n\n\nmodule.exports = formatFn => {\n  if (formatFn.length > 2) {\n    throw new InvalidFormatError(formatFn);\n  }\n  /*\n   * function Format (options)\n   * Base prototype which calls a `_format`\n   * function and pushes the result.\n   */\n\n\n  function Format(options = {}) {\n    this.options = options;\n  }\n\n  Format.prototype.transform = formatFn; //\n  // Create a function which returns new instances of\n  // FormatWrap for simple syntax like:\n  //\n  // require('winston').formats.json();\n  //\n\n  function createFormatWrap(opts) {\n    return new Format(opts);\n  } //\n  // Expose the FormatWrap through the create function\n  // for testability.\n  //\n\n\n  createFormatWrap.Format = Format;\n  return createFormatWrap;\n};","map":{"version":3,"sources":["/home/conrad/Documents/tarot/tarot-cards/node_modules/logform/format.js"],"names":["InvalidFormatError","Error","constructor","formatFn","toString","split","captureStackTrace","module","exports","length","Format","options","prototype","transform","createFormatWrap","opts"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AACA,MAAMA,kBAAN,SAAiCC,KAAjC,CAAuC;AACrCC,EAAAA,WAAW,CAACC,QAAD,EAAW;AACpB,UAAO;AACX,SAASA,QAAQ,CAACC,QAAT,GAAoBC,KAApB,CAA0B,IAA1B,EAAgC,CAAhC,CAAmC,IADxC;AAGAJ,IAAAA,KAAK,CAACK,iBAAN,CAAwB,IAAxB,EAA8BN,kBAA9B;AACD;;AANoC;AASvC;AACA;AACA;AACA;;;AACAO,MAAM,CAACC,OAAP,GAAiBL,QAAQ,IAAI;AAC3B,MAAIA,QAAQ,CAACM,MAAT,GAAkB,CAAtB,EAAyB;AACvB,UAAM,IAAIT,kBAAJ,CAAuBG,QAAvB,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,WAASO,MAAT,CAAgBC,OAAO,GAAG,EAA1B,EAA8B;AAC5B,SAAKA,OAAL,GAAeA,OAAf;AACD;;AAEDD,EAAAA,MAAM,CAACE,SAAP,CAAiBC,SAAjB,GAA6BV,QAA7B,CAd2B,CAgB3B;AACA;AACA;AACA;AACA;AACA;;AACA,WAASW,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,WAAO,IAAIL,MAAJ,CAAWK,IAAX,CAAP;AACD,GAxB0B,CA0B3B;AACA;AACA;AACA;;;AACAD,EAAAA,gBAAgB,CAACJ,MAAjB,GAA0BA,MAA1B;AACA,SAAOI,gBAAP;AACD,CAhCD","sourcesContent":["'use strict';\n\n/*\n * Displays a helpful message and the source of\n * the format when it is invalid.\n */\nclass InvalidFormatError extends Error {\n  constructor(formatFn) {\n    super(`Format functions must be synchronous taking a two arguments: (info, opts)\nFound: ${formatFn.toString().split('\\n')[0]}\\n`);\n\n    Error.captureStackTrace(this, InvalidFormatError);\n  }\n}\n\n/*\n * function format (formatFn)\n * Returns a create function for the `formatFn`.\n */\nmodule.exports = formatFn => {\n  if (formatFn.length > 2) {\n    throw new InvalidFormatError(formatFn);\n  }\n\n  /*\n   * function Format (options)\n   * Base prototype which calls a `_format`\n   * function and pushes the result.\n   */\n  function Format(options = {}) {\n    this.options = options;\n  }\n\n  Format.prototype.transform = formatFn;\n\n  //\n  // Create a function which returns new instances of\n  // FormatWrap for simple syntax like:\n  //\n  // require('winston').formats.json();\n  //\n  function createFormatWrap(opts) {\n    return new Format(opts);\n  }\n\n  //\n  // Expose the FormatWrap through the create function\n  // for testability.\n  //\n  createFormatWrap.Format = Format;\n  return createFormatWrap;\n};\n"]},"metadata":{},"sourceType":"script"}